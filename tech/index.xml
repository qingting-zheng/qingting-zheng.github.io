<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>tech on QingTing</title>
    <link>https://qingting-zheng.github.io:443/tech/</link>
    <description>Recent content in tech on QingTing</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-Hans</language>
    <lastBuildDate>Tue, 18 Sep 2018 23:51:34 +0800</lastBuildDate><atom:link href="https://qingting-zheng.github.io:443/tech/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>深入解析微服务网关Spring Cloud Gateway（三十三）全局过滤器-NettyRoutingFilter</title>
      <link>https://qingting-zheng.github.io:443/tech/2021-01/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3spring-cloud-gateway%E4%B8%89%E5%8D%81%E4%B8%89%E5%85%A8%E5%B1%80%E8%BF%87%E6%BB%A4%E5%99%A8-nettyroutingfilter/</link>
      <pubDate>Fri, 15 Jan 2021 10:01:15 +0800</pubDate>
      
      <guid>https://qingting-zheng.github.io:443/tech/2021-01/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3spring-cloud-gateway%E4%B8%89%E5%8D%81%E4%B8%89%E5%85%A8%E5%B1%80%E8%BF%87%E6%BB%A4%E5%99%A8-nettyroutingfilter/</guid>
      <description>系新的组件解析系列文章《微服务网关 Spring Cloud Gageway解析》的介绍与深入讲解。欢迎关注、转发、评论。 NettyRoutingFilter 如果位于ServerWebExchangeUtils.GATEWAY_REQUEST_URL_ATTR请求属性中的URL具有http或https前缀，Netty路由过滤器将运行。 它使用Netty HttpClient进行下游代理请求。 响应放在ServerWebExchangeUtils.CLIENT_</description>
    </item>
    
    <item>
      <title>深入解析微服务网关Spring Cloud Gateway（三十七）API 接口详解</title>
      <link>https://qingting-zheng.github.io:443/tech/2021-01/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3spring-cloud-gateway%E4%B8%89%E5%8D%81%E4%B8%83api-%E6%8E%A5%E5%8F%A3%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Sun, 03 Jan 2021 10:01:15 +0800</pubDate>
      
      <guid>https://qingting-zheng.github.io:443/tech/2021-01/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3spring-cloud-gateway%E4%B8%89%E5%8D%81%E4%B8%83api-%E6%8E%A5%E5%8F%A3%E8%AF%A6%E8%A7%A3/</guid>
      <description>系新的组件解析系列文章《微服务网关 Spring Cloud Gageway解析》的介绍与深入讲解。欢迎关注、转发、评论。 在前面的一篇文章，我们介绍了 Spring Cloud 的API 端点概览。网关一共提供了7个内置端点。分别为： /actuator/gateway/routes/{id},methods=[DELETE]，删除单个路由 /actuator/gateway/routes/{id},methods=[POST]，增加单个路由 /act</description>
    </item>
    
    <item>
      <title>深入解析微服务网关Spring Cloud Gateway（三十六）API 端点概览</title>
      <link>https://qingting-zheng.github.io:443/tech/2020-12/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3spring-cloud-gateway%E4%B8%89%E5%8D%81%E5%85%ADapi-%E7%AB%AF%E7%82%B9%E6%A6%82%E8%A7%88/</link>
      <pubDate>Tue, 29 Dec 2020 10:01:15 +0800</pubDate>
      
      <guid>https://qingting-zheng.github.io:443/tech/2020-12/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3spring-cloud-gateway%E4%B8%89%E5%8D%81%E5%85%ADapi-%E7%AB%AF%E7%82%B9%E6%A6%82%E8%A7%88/</guid>
      <description>新的组件解析系列文章《微服务网关 Spring Cloud Gageway解析》的介绍与深入讲解。欢迎关注、转发、评论。 API端点 Spring Cloud Gateway提供了内置的端点，用于提供路由相关的操作，如过滤器列表、路由列表、单个路由信息等等。首先看一下内置端点的构造器。 @RestControllerEndpoint(id = &amp;#34;gateway&amp;#34;) public class GatewayControllerEndpoint implements ApplicationEventPublisherAware { //应用事件发布器 private ApplicationEventPublisher publisher; public GatewayControllerEndpoint(RouteDefinitionLocator routeDefinitionLocator, List&amp;lt;GlobalFilter&amp;gt; globalFilters, List&amp;lt;GatewayFilterFactory&amp;gt; GatewayFilters, RouteDefinitionWriter routeDefinitionWriter, RouteLocator routeLocator) { this.routeDefinitionLocator = routeDefinitionLocator; this.globalFilters = globalFilters; this.GatewayFilters = GatewayFilters; this.routeDefinitionWriter = routeDefinitionWriter; this.routeLocator = routeLocator; } //... } Spring Cloud Gateway的内置端点纳管到Spring Boot-Act</description>
    </item>
    
    <item>
      <title>深入解析微服务网关Spring Cloud Gateway（三十五）全局过滤器-其他过滤器</title>
      <link>https://qingting-zheng.github.io:443/tech/2020-12/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3spring-cloud-gateway%E4%B8%89%E5%8D%81%E4%BA%94%E5%85%A8%E5%B1%80%E8%BF%87%E6%BB%A4%E5%99%A8-%E5%85%B6%E4%BB%96%E8%BF%87%E6%BB%A4%E5%99%A8/</link>
      <pubDate>Sun, 27 Dec 2020 10:01:15 +0800</pubDate>
      
      <guid>https://qingting-zheng.github.io:443/tech/2020-12/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3spring-cloud-gateway%E4%B8%89%E5%8D%81%E4%BA%94%E5%85%A8%E5%B1%80%E8%BF%87%E6%BB%A4%E5%99%A8-%E5%85%B6%E4%BB%96%E8%BF%87%E6%BB%A4%E5%99%A8/</guid>
      <description>新的组件解析系列文章《微服务网关 Spring Cloud Gageway解析》的介绍与深入讲解。欢迎关注、转发、评论。 WebClientHttpRoutingFilter WebClientHttpRoutingFilter，Http路由网关过滤器。其根据http或https前缀过滤处理，使用基于 WebClient 实现的 HttpClient 请求后端 Http 服务。对于http或https前缀的过滤处理，NettyRoutingFilter是Spring Cloud Gateway的默认实现。基于WebClient的实现还处</description>
    </item>
    
    <item>
      <title>深入解析微服务网关Spring Cloud Gateway（三十四）全局过滤器-NettyWriteResponseFilter与RouteToRequestUrlFilter</title>
      <link>https://qingting-zheng.github.io:443/tech/2020-12/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3spring-cloud-gateway%E4%B8%89%E5%8D%81%E5%9B%9B%E5%85%A8%E5%B1%80%E8%BF%87%E6%BB%A4%E5%99%A8-nettywriteresponsefilter%E4%B8%8Eroutetorequesturlfilter/</link>
      <pubDate>Mon, 21 Dec 2020 10:01:15 +0800</pubDate>
      
      <guid>https://qingting-zheng.github.io:443/tech/2020-12/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3spring-cloud-gateway%E4%B8%89%E5%8D%81%E5%9B%9B%E5%85%A8%E5%B1%80%E8%BF%87%E6%BB%A4%E5%99%A8-nettywriteresponsefilter%E4%B8%8Eroutetorequesturlfilter/</guid>
      <description>新的组件解析系列文章《微服务网关 Spring Cloud Gageway解析》的介绍与深入讲解。欢迎关注、转发、评论。 NettyWriteResponseFilter 与NettyRoutingFilter成对使用。“预”过滤阶段没有任何内容，因为CLIENT_RESPONSE_ATTR在WebHandler运行之前不会被添加。 @Override public Mono&amp;lt;Void&amp;gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) { return chain.filter(exchange).then(Mono.defer(() -&amp;gt; { HttpClientResponse clientResponse = exchange.getAttribute(CLIENT_RESPONSE_ATTR); if (clientResponse == null) { return Mono.empty(); } ServerHttpResponse response = exchange.getResponse(); //将响应写到客户端 NettyDataBufferFactory factory = (NettyDataBufferFactory) response.bufferFactory(); final Flux&amp;lt;NettyDataBuffer&amp;gt; body = clientResponse.receive() .retain() .map(factory::wrap); MediaType contentType = response.getHeaders().getContentType(); return (isStreamingMediaType(contentType) ? response.writeAndFlushWith(body.map(Flux::just)) : response.writeWith(body)); })); } 如果Server</description>
    </item>
    
    <item>
      <title>深入解析微服务网关Spring Cloud Gateway（三十三）全局过滤器-NettyRoutingFilter</title>
      <link>https://qingting-zheng.github.io:443/tech/2020-12/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3spring-cloud-gateway%E4%B8%89%E5%8D%81%E4%B8%89%E5%85%A8%E5%B1%80%E8%BF%87%E6%BB%A4%E5%99%A8-nettyroutingfilter/</link>
      <pubDate>Tue, 15 Dec 2020 10:01:15 +0800</pubDate>
      
      <guid>https://qingting-zheng.github.io:443/tech/2020-12/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3spring-cloud-gateway%E4%B8%89%E5%8D%81%E4%B8%89%E5%85%A8%E5%B1%80%E8%BF%87%E6%BB%A4%E5%99%A8-nettyroutingfilter/</guid>
      <description>系新的组件解析系列文章《微服务网关 Spring Cloud Gageway解析》的介绍与深入讲解。欢迎关注、转发、评论。 NettyRoutingFilter 如果位于ServerWebExchangeUtils.GATEWAY_REQUEST_URL_ATTR请求属性中的URL具有http或https前缀，Netty路由过滤器将运行。 它使用Netty HttpClient进行下游代理请求。 响应放在ServerWebExchangeUtils.CLIENT_</description>
    </item>
    
    <item>
      <title>深入解析微服务网关Spring Cloud Gateway（三十二）全局过滤器-LoadBalancerClientFilter</title>
      <link>https://qingting-zheng.github.io:443/tech/2020-12/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3spring-cloud-gateway%E4%B8%89%E5%8D%81%E4%BA%8C%E5%85%A8%E5%B1%80%E8%BF%87%E6%BB%A4%E5%99%A8-loadbalancerclientfilter/</link>
      <pubDate>Sat, 05 Dec 2020 10:01:15 +0800</pubDate>
      
      <guid>https://qingting-zheng.github.io:443/tech/2020-12/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3spring-cloud-gateway%E4%B8%89%E5%8D%81%E4%BA%8C%E5%85%A8%E5%B1%80%E8%BF%87%E6%BB%A4%E5%99%A8-loadbalancerclientfilter/</guid>
      <description>系新的组件解析系列文章《微服务网关 Spring Cloud Gageway解析》的介绍与深入讲解。欢迎关注、转发、评论。 LoadBalancerClientFilter LoadBalancerClientFilter在交换属性ServerWebExchangeUtils.GATEWAY_REQUEST_URL_ATTR中查找URI。 如果url有一个lb前缀，即lb：// myservice，它将使用LoadBalancerClient将名称解析为实际的主机和端口，如</description>
    </item>
    
    <item>
      <title>深入解析微服务网关Spring Cloud Gateway（三十一）全局过滤器</title>
      <link>https://qingting-zheng.github.io:443/tech/2020-11/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3spring-cloud-gateway%E4%B8%89%E5%8D%81%E4%B8%80%E5%85%A8%E5%B1%80%E8%BF%87%E6%BB%A4%E5%99%A8/</link>
      <pubDate>Mon, 30 Nov 2020 10:01:15 +0800</pubDate>
      
      <guid>https://qingting-zheng.github.io:443/tech/2020-11/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3spring-cloud-gateway%E4%B8%89%E5%8D%81%E4%B8%80%E5%85%A8%E5%B1%80%E8%BF%87%E6%BB%A4%E5%99%A8/</guid>
      <description>系新的组件解析系列文章《微服务网关 Spring Cloud Gageway解析》的介绍与深入讲解。欢迎关注、转发、评论。 全局过滤器 GlobalFilter接口与GatewayFilter具有相同的方法定义。 全局过滤器是一系列特殊的过滤器，将会根据条件应用到所有的路由中，该接口的设计和用法在将老的版本中可能会发生变化。全局过滤器用于拦截链式的web请求，可以实现横切的、与应用无关的需求，比如安全、访问超时的设定等等。前面</description>
    </item>
    
    <item>
      <title>深入解析微服务网关Spring Cloud Gateway（三十）网关过滤器-续6</title>
      <link>https://qingting-zheng.github.io:443/tech/2020-11/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3spring-cloud-gateway%E4%B8%89%E5%8D%81%E7%BD%91%E5%85%B3%E8%BF%87%E6%BB%A4%E5%99%A8-%E7%BB%AD6/</link>
      <pubDate>Mon, 23 Nov 2020 10:01:15 +0800</pubDate>
      
      <guid>https://qingting-zheng.github.io:443/tech/2020-11/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3spring-cloud-gateway%E4%B8%89%E5%8D%81%E7%BD%91%E5%85%B3%E8%BF%87%E6%BB%A4%E5%99%A8-%E7%BB%AD6/</guid>
      <description>系新的组件解析系列文章《微服务网关 Spring Cloud Gageway解析》的介绍与深入讲解。欢迎关注、转发、评论。 SetRequestHeaderGatewayFilterFactory 属于Header类型的过滤器，该过滤器接收两个参数：头部名和值。 spring:cloud:gateway:routes:- id:setrequestheader_routeuri:http://example.orgfilters:- SetRequestHeader=X-request-Foo, Bar当请求经过网关转发时，该过滤器将会用给定的名字替换所有的头部，而不是增加。因此传递到下游的请求头部为X-request-Foo: Bar。 SetResponseHeaderGatewayFilterFactory 属于Header类型的过滤器，该过滤器接收两个参数：头部名和值。 spring:cloud:gateway:routes:- id:setresponseheader_routeuri:http://example.orgfilters:- SetResponseHeader=X-Response-Foo, Bar该过滤器将</description>
    </item>
    
    <item>
      <title>深入解析微服务网关Spring Cloud Gateway（二十九）网关过滤器-续5</title>
      <link>https://qingting-zheng.github.io:443/tech/2020-11/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3spring-cloud-gateway%E4%BA%8C%E5%8D%81%E4%B9%9D%E7%BD%91%E5%85%B3%E8%BF%87%E6%BB%A4%E5%99%A8-%E7%BB%AD5/</link>
      <pubDate>Tue, 03 Nov 2020 10:01:15 +0800</pubDate>
      
      <guid>https://qingting-zheng.github.io:443/tech/2020-11/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3spring-cloud-gateway%E4%BA%8C%E5%8D%81%E4%B9%9D%E7%BD%91%E5%85%B3%E8%BF%87%E6%BB%A4%E5%99%A8-%E7%BB%AD5/</guid>
      <description>系新的组件解析系列文章《微服务网关 Spring Cloud Gageway解析》的介绍与深入讲解。欢迎关注、转发、评论。 SaveSessionGatewayFilterFactory 属于session类型的过滤器，在转发到调用的下游时，该过滤器强制执行WebSession::save操作。这是一种特殊的用途，当使用类似于Spring Session MongoDB这种惰性数据存储并且需要确保在转发之前session的数据已经被存储。 spring:cloud:gateway:routes:- id:save_sessionuri:http://example.orgpredicates:- Path=/foo/**filters:- SaveSession当我们集成了Spring Secur</description>
    </item>
    
    <item>
      <title>深入解析微服务网关Spring Cloud Gateway（二十八）网关过滤器-续4</title>
      <link>https://qingting-zheng.github.io:443/tech/2020-10/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3spring-cloud-gateway%E4%BA%8C%E5%8D%81%E5%85%AB%E7%BD%91%E5%85%B3%E8%BF%87%E6%BB%A4%E5%99%A8-%E7%BB%AD4/</link>
      <pubDate>Fri, 30 Oct 2020 10:01:15 +0800</pubDate>
      
      <guid>https://qingting-zheng.github.io:443/tech/2020-10/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3spring-cloud-gateway%E4%BA%8C%E5%8D%81%E5%85%AB%E7%BD%91%E5%85%B3%E8%BF%87%E6%BB%A4%E5%99%A8-%E7%BB%AD4/</guid>
      <description>系新的组件解析系列文章《微服务网关 Spring Cloud Gageway解析》的介绍与深入讲解。欢迎关注、转发、评论。 RequestRateLimiterGatewayFilterFactory 属于限流类型的过滤器，该过滤器接收三个参数：令牌桶上限、平均填充速度和关键字Bean名称。 @Bean KeyResolver userKeyResolver() { return exchange -&amp;gt; Mono.just(exchange.getRequest().getQueryParams().getFirst(&amp;#34;user&amp;#34;)); } 定义限流键解析器 Bean 对象名字，在配置文件中将会使用到。 spring:cloud:gateway:routes:- id:requestratelimiter_routeuri:http://example.orgfilters:- RequestRateLimiter=10, 20,#{@userKeyResolver}如上配置了每个用户请求，每秒的速率限定为10，以及令牌桶的上限为20，而KeyResolv</description>
    </item>
    
    <item>
      <title>深入解析微服务网关Spring Cloud Gateway（二十七）网关过滤器-续3 </title>
      <link>https://qingting-zheng.github.io:443/tech/2020-10/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3spring-cloud-gateway%E4%BA%8C%E5%8D%81%E4%B8%83%E7%BD%91%E5%85%B3%E8%BF%87%E6%BB%A4%E5%99%A8-%E7%BB%AD3/</link>
      <pubDate>Sat, 24 Oct 2020 10:01:15 +0800</pubDate>
      
      <guid>https://qingting-zheng.github.io:443/tech/2020-10/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3spring-cloud-gateway%E4%BA%8C%E5%8D%81%E4%B8%83%E7%BD%91%E5%85%B3%E8%BF%87%E6%BB%A4%E5%99%A8-%E7%BB%AD3/</guid>
      <description>系新的组件解析系列文章《微服务网关 Spring Cloud Gageway解析》的介绍与深入讲解。欢迎关注、转发、评论。 PrefixPathGatewayFilterFactory 属于路径类型的过滤器，只接收一个prefix前缀参数。 spring:cloud:gateway:routes:- id:prefixpath_routeuri:http://example.orgfilters:- PrefixPath=/mypathprefixpath_route的路由配置，会将所有匹配的请求的路径加上/mypath前缀。比如一个请求的路径是/hello，转发的时候变成/mypath/hello。 PreserveHostHeaderGatewayFilterFactory PreserveHostHeader 过滤器没有参数。 spring:cloud:gateway:routes:- id:preserve_host_routeuri:http://example.orgfilters:- Preserv</description>
    </item>
    
    <item>
      <title>深入解析微服务网关Spring Cloud Gateway（二十六）网关过滤器-Hystrix过滤器 </title>
      <link>https://qingting-zheng.github.io:443/tech/2020-10/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3spring-cloud-gateway%E4%BA%8C%E5%8D%81%E5%85%AD%E7%BD%91%E5%85%B3%E8%BF%87%E6%BB%A4%E5%99%A8-hystrix%E8%BF%87%E6%BB%A4%E5%99%A8/</link>
      <pubDate>Fri, 23 Oct 2020 10:01:15 +0800</pubDate>
      
      <guid>https://qingting-zheng.github.io:443/tech/2020-10/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3spring-cloud-gateway%E4%BA%8C%E5%8D%81%E5%85%AD%E7%BD%91%E5%85%B3%E8%BF%87%E6%BB%A4%E5%99%A8-hystrix%E8%BF%87%E6%BB%A4%E5%99%A8/</guid>
      <description>系新的组件解析系列文章《微服务网关 Spring Cloud Gageway解析》的介绍与深入讲解。欢迎关注、转发、评论。 Hystrix过滤器 属于熔断类型的过滤器，接收一个参数：HystrixCommand的命令。 spring:cloud:gateway:routes:- id:hytstrix_routeuri:http://example.orgfilters:- name:Hystrixargs:name:fallbackcmdfallbackUri:forward:/fallbackcontroller如上的配置将会用一个HystrixCommand名为fallb</description>
    </item>
    
    <item>
      <title>深入解析微服务网关Spring Cloud Gateway（二十五）网关过滤器-续2</title>
      <link>https://qingting-zheng.github.io:443/tech/2020-10/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3spring-cloud-gateway%E4%BA%8C%E5%8D%81%E4%BA%94%E7%BD%91%E5%85%B3%E8%BF%87%E6%BB%A4%E5%99%A8-%E7%BB%AD2/</link>
      <pubDate>Tue, 20 Oct 2020 10:01:15 +0800</pubDate>
      
      <guid>https://qingting-zheng.github.io:443/tech/2020-10/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3spring-cloud-gateway%E4%BA%8C%E5%8D%81%E4%BA%94%E7%BD%91%E5%85%B3%E8%BF%87%E6%BB%A4%E5%99%A8-%E7%BB%AD2/</guid>
      <description>系新的组件解析系列文章《微服务网关 Spring Cloud Gageway解析》的介绍与深入讲解。欢迎关注、转发、评论。 增加请求头部的过滤器 属于Header类的过滤器，该过滤器接收两个参数：头部名和值。 spring:cloud:gateway:routes:- id:add_request_header_routeuri:http://example.orgfilters:- AddRequestHeader=X-Request-Foo, Baradd_request_header_route路由将会为匹配的请求，增加X-Request-Foo:Bar头部，并将头部传递到下游。 public class AddRequestHeaderGatewayFilterFactory extends AbstractNameValueGatewayFilterFactory { @Override public GatewayFilter apply(NameValueConfig config) { return (exchange, chain) -&amp;gt; { ServerHttpRequest request = exchange.getRequest().mutate() .header(config.getName(), config.getValue()) .build(); return chain.filter(exchange.mutate().request(request).build()); }; } } 获取到配置中的过</description>
    </item>
    
    <item>
      <title>深入解析微服务网关Spring Cloud Gateway（二十四）网关过滤器-续1</title>
      <link>https://qingting-zheng.github.io:443/tech/2020-10/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3spring-cloud-gateway%E4%BA%8C%E5%8D%81%E5%9B%9B%E7%BD%91%E5%85%B3%E8%BF%87%E6%BB%A4%E5%99%A8-%E7%BB%AD1/</link>
      <pubDate>Sun, 18 Oct 2020 10:01:15 +0800</pubDate>
      
      <guid>https://qingting-zheng.github.io:443/tech/2020-10/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3spring-cloud-gateway%E4%BA%8C%E5%8D%81%E5%9B%9B%E7%BD%91%E5%85%B3%E8%BF%87%E6%BB%A4%E5%99%A8-%E7%BB%AD1/</guid>
      <description>系新的组件解析系列文章《微服务网关 Spring Cloud Gageway解析》的介绍与深入讲解。欢迎关注、转发、评论。 网关过滤器工厂接口 路由过滤器允许以某种方式修改传入的HTTP请求或传出的HTTP响应。 路由过滤器的作用域是一个特定的路由。Spring Cloud Gateway包含许多内置的GatewayFilter工厂。首先看一下GatewayFilterFactory接口中定义的方法。 public interface GatewayFilterFactory&amp;lt;C&amp;gt; extends ShortcutConfigurable, Configurable&amp;lt;C&amp;gt; { default GatewayFilter apply(Consumer&amp;lt;C&amp;gt; consumer) { C config = newConfig(); consumer.accept(config); return apply(config);</description>
    </item>
    
    <item>
      <title>深入解析微服务网关Spring Cloud Gateway（二十三）网关过滤器</title>
      <link>https://qingting-zheng.github.io:443/tech/2020-10/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3spring-cloud-gateway%E4%BA%8C%E5%8D%81%E4%B8%89%E7%BD%91%E5%85%B3%E8%BF%87%E6%BB%A4%E5%99%A8/</link>
      <pubDate>Fri, 16 Oct 2020 10:01:15 +0800</pubDate>
      
      <guid>https://qingting-zheng.github.io:443/tech/2020-10/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3spring-cloud-gateway%E4%BA%8C%E5%8D%81%E4%B8%89%E7%BD%91%E5%85%B3%E8%BF%87%E6%BB%A4%E5%99%A8/</guid>
      <description>系新的组件解析系列文章《微服务网关 Spring Cloud Gageway解析》的介绍与深入讲解。欢迎关注、转发、评论。 网关过滤器 GatewayFilter网关过滤器用于拦截和链式处理web请求，可以实现横切的、与应用无关的需求，比如安全、访问超时的设定等等。 public interface GatewayFilter { Mono&amp;lt;Void&amp;gt; filter(ServerWebExchange exchange, GatewayFilterChain chain); } 接口中定义了唯一的方法#filter，处理web请求，并且可以通过给定的过滤器链传递到下一个过滤器。该接口有多个实现类，下面看一下该接口的类图</description>
    </item>
    
    <item>
      <title>深入解析微服务网关Spring Cloud Gateway（二十二）进阶应用路由断言续3</title>
      <link>https://qingting-zheng.github.io:443/tech/2020-10/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3spring-cloud-gateway%E4%BA%8C%E5%8D%81%E4%BA%8C%E8%BF%9B%E9%98%B6%E5%BA%94%E7%94%A8%E8%B7%AF%E7%94%B1%E6%96%AD%E8%A8%80%E7%BB%AD3/</link>
      <pubDate>Sun, 11 Oct 2020 10:01:15 +0800</pubDate>
      
      <guid>https://qingting-zheng.github.io:443/tech/2020-10/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3spring-cloud-gateway%E4%BA%8C%E5%8D%81%E4%BA%8C%E8%BF%9B%E9%98%B6%E5%BA%94%E7%94%A8%E8%B7%AF%E7%94%B1%E6%96%AD%E8%A8%80%E7%BB%AD3/</guid>
      <description>系新的组件解析系列文章《微服务网关 Spring Cloud Gageway解析》的介绍与深入讲解。欢迎关注、转发、评论。 HeaderRoutePredicateFactory HeaderRoutePredicateFactory属于header类型的路由断言工厂，接收两个参数：header名和一个正则表达式。 spring: cloud: gateway: routes: - id: header_route uri: http://example.org predicates: - Header=X-Request-Id, \d+ header_route中路由断言的配置，如果请求的头部中有X-Request-Id，并且该头部值匹配\d+正则表达式，则与该路由匹配。具</description>
    </item>
    
    <item>
      <title>深入解析微服务网关Spring Cloud Gateway（二十一）路由断言-续1 </title>
      <link>https://qingting-zheng.github.io:443/tech/2020-09/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3spring-cloud-gateway%E4%BA%8C%E5%8D%81%E4%B8%80%E8%B7%AF%E7%94%B1%E6%96%AD%E8%A8%80-%E7%BB%AD1/</link>
      <pubDate>Mon, 14 Sep 2020 10:01:15 +0800</pubDate>
      
      <guid>https://qingting-zheng.github.io:443/tech/2020-09/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3spring-cloud-gateway%E4%BA%8C%E5%8D%81%E4%B8%80%E8%B7%AF%E7%94%B1%E6%96%AD%E8%A8%80-%E7%BB%AD1/</guid>
      <description>系新的组件解析系列文章《微服务网关 Spring Cloud Gageway解析》的介绍与深入讲解。欢迎关注、转发、评论。 AfterRoutePredicateFactory AfterRoutePredicateFactory属于Datetime类型的路由断言工厂，接收一个日期参数。该路由断言用于匹配请求时间满足在配置时间之后。如： spring:cloud:gateway:routes:- id:after_routeuri:http://example.orgpredicates:- After=2018-03-20T10:42:47.789+08:00[Asia/Shanghai]上面的配置文件指定了路由的断言。关键</description>
    </item>
    
    <item>
      <title>深入解析微服务网关Spring Cloud Gateway（二十一）路由断言-续1 </title>
      <link>https://qingting-zheng.github.io:443/tech/2020-09/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3spring-cloud-gateway%E4%BA%8C%E5%8D%81%E4%B8%80%E8%B7%AF%E7%94%B1%E6%96%AD%E8%A8%80-%E7%BB%AD1/</link>
      <pubDate>Mon, 14 Sep 2020 10:01:15 +0800</pubDate>
      
      <guid>https://qingting-zheng.github.io:443/tech/2020-09/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3spring-cloud-gateway%E4%BA%8C%E5%8D%81%E4%B8%80%E8%B7%AF%E7%94%B1%E6%96%AD%E8%A8%80-%E7%BB%AD1/</guid>
      <description>系新的组件解析系列文章《微服务网关 Spring Cloud Gageway解析》的介绍与深入讲解。欢迎关注、转发、评论。 AfterRoutePredicateFactory AfterRoutePredicateFactory属于Datetime类型的路由断言工厂，接收一个日期参数。该路由断言用于匹配请求时间满足在配置时间之后。如： spring:cloud:gateway:routes:- id:after_routeuri:http://example.orgpredicates:- After=2018-03-20T10:42:47.789+08:00[Asia/Shanghai]上面的配置文件指定了路由的断言。关键</description>
    </item>
    
    <item>
      <title>深入解析微服务网关Spring Cloud Gateway（二十）路由断言</title>
      <link>https://qingting-zheng.github.io:443/tech/2020-09/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3spring-cloud-gateway%E4%BA%8C%E5%8D%81%E8%B7%AF%E7%94%B1%E6%96%AD%E8%A8%80/</link>
      <pubDate>Thu, 03 Sep 2020 10:01:15 +0800</pubDate>
      
      <guid>https://qingting-zheng.github.io:443/tech/2020-09/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3spring-cloud-gateway%E4%BA%8C%E5%8D%81%E8%B7%AF%E7%94%B1%E6%96%AD%E8%A8%80/</guid>
      <description>系新的组件解析系列文章《微服务网关 Spring Cloud Gageway解析》的介绍与深入讲解。欢迎关注、转发、评论。 路由断言 Spring Cloud Gateway 创建 Route 对象时，使用 RoutePredicateFactory 创建 Predicate对象。Predicate对象可以赋值给 Route。简单来说，路由断言用于匹配请求对应的 Route。路由决策工厂RoutePredicateFactory的定义如下： public interface RoutePredicateFactory&amp;lt;C&amp;gt; extends ShortcutConfigurable, Configurable&amp;lt;C&amp;gt; { String PATTERN_KEY = &amp;#34;pattern&amp;#34;; // useful for javadsl default Predicate&amp;lt;ServerWebExchange&amp;gt; apply(Consumer&amp;lt;C&amp;gt; consumer) { C config = newConfig(); consumer.accept(config); beforeApply(config); return apply(config); } default void beforeApply(C config) {} default String name() { return NameUtils.normalizeRoutePredicateName(getClass()); }</description>
    </item>
    
    <item>
      <title>深入解析微服务网关Spring Cloud Gateway（十九）缓存方式的RouteLocator</title>
      <link>https://qingting-zheng.github.io:443/tech/2020-08/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3spring-cloud-gateway%E5%8D%81%E4%B9%9D%E7%BC%93%E5%AD%98%E6%96%B9%E5%BC%8F%E7%9A%84routelocator/</link>
      <pubDate>Mon, 31 Aug 2020 10:01:15 +0800</pubDate>
      
      <guid>https://qingting-zheng.github.io:443/tech/2020-08/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3spring-cloud-gateway%E5%8D%81%E4%B9%9D%E7%BC%93%E5%AD%98%E6%96%B9%E5%BC%8F%E7%9A%84routelocator/</guid>
      <description>系新的组件解析系列文章《微服务网关 Spring Cloud Gageway解析》的介绍与深入讲解。欢迎关注、转发、评论。 缓存方式的RouteLocator CachingRouteLocator是缓存路由的RouteLocator实现类。想要获取路由，只需要调用RouteLocator接口的getRoutes() 方法即可。 public class CachingRouteLocator implements RouteLocator { private final RouteLocator delegate; private final AtomicReference&amp;lt;List&amp;lt;Route&amp;gt;&amp;gt; cachedRoutes = new AtomicReference&amp;lt;&amp;gt;(); public CachingRouteLocator(RouteLocator delegate) { this.delegate = delegate; this.cachedRoutes.compareAndSet(null, collectRoutes()); } private List&amp;lt;Route&amp;gt; collectRoutes() { List&amp;lt;Route&amp;gt; routes = this.delegate.getRoutes().collectList().block(); AnnotationAwareOrderComparator.sort(routes); return routes; } @Override public Flux&amp;lt;Route&amp;gt; getRoutes() { return Flux.fromIterable(this.cachedRoutes.get()); } //... } 这</description>
    </item>
    
    <item>
      <title>深入解析微服务网关Spring Cloud Gateway（十八）组合的RouteDefinitionLocator</title>
      <link>https://qingting-zheng.github.io:443/tech/2020-08/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3spring-cloud-gateway%E5%8D%81%E5%85%AB%E7%BB%84%E5%90%88%E7%9A%84routedefinitionlocator/</link>
      <pubDate>Sat, 29 Aug 2020 10:01:15 +0800</pubDate>
      
      <guid>https://qingting-zheng.github.io:443/tech/2020-08/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3spring-cloud-gateway%E5%8D%81%E5%85%AB%E7%BB%84%E5%90%88%E7%9A%84routedefinitionlocator/</guid>
      <description>系新的组件解析系列文章《微服务网关 Spring Cloud Gageway解析》的介绍与深入讲解。欢迎关注、转发、评论。 路由定位器 直接获取路由的方法是通过RouteLocator接口获取。同样，该顶级接口有多个实现类，如下为RouteLocator的类图。 public interface RouteLocator { Flux&amp;lt;Route&amp;gt; getRoutes(); } 与上一节介绍的RouteDefinitionLocator接口类似，只有一个getRoutes方法用以获取路由信息。 public class Route implements Ordered { //路由Id private final String id; //</description>
    </item>
    
    <item>
      <title>深入解析微服务网关Spring Cloud Gateway（十七）组合的RouteDefinitionLocator</title>
      <link>https://qingting-zheng.github.io:443/tech/2020-08/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3spring-cloud-gateway%E5%8D%81%E4%B8%83%E7%BB%84%E5%90%88%E7%9A%84routedefinitionlocator/</link>
      <pubDate>Fri, 28 Aug 2020 10:01:15 +0800</pubDate>
      
      <guid>https://qingting-zheng.github.io:443/tech/2020-08/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3spring-cloud-gateway%E5%8D%81%E4%B8%83%E7%BB%84%E5%90%88%E7%9A%84routedefinitionlocator/</guid>
      <description>系新的组件解析系列文章《微服务网关 Spring Cloud Gageway解析》的介绍与深入讲解。欢迎关注、转发、评论。 组合的RouteDefinitionLocator CompositeRouteDefinitionLocator组合多种 RouteDefinitionLocator的实现，为 RouteDefinitionRouteLocator提供统一入口。代码如下： public class CompositeRouteDefinitionLocator implements RouteDefinitionLocator { private final Flux&amp;lt;RouteDefinitionLocator&amp;gt; delegates; public CompositeRouteDefinitionLocator(Flux&amp;lt;RouteDefinitionLocator&amp;gt; delegates) { this.delegates = delegates; } @Override public Flux&amp;lt;RouteDefinition&amp;gt; getRouteDefinitions() { return this.delegates.flatMap(RouteDefinitionLocator::getRouteDefinitions);</description>
    </item>
    
    <item>
      <title>深入解析微服务网关Spring Cloud Gateway（十六）基于服务发现的RouteDefinitionLocator</title>
      <link>https://qingting-zheng.github.io:443/tech/2020-08/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3spring-cloud-gateway%E5%8D%81%E5%85%AD%E5%9F%BA%E4%BA%8E%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E7%9A%84routedefinitionlocator/</link>
      <pubDate>Sat, 22 Aug 2020 10:01:15 +0800</pubDate>
      
      <guid>https://qingting-zheng.github.io:443/tech/2020-08/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3spring-cloud-gateway%E5%8D%81%E5%85%AD%E5%9F%BA%E4%BA%8E%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E7%9A%84routedefinitionlocator/</guid>
      <description>系新的组件解析系列文章《微服务网关 Spring Cloud Gageway解析》的介绍与深入讲解。欢迎关注、转发、评论。 基于服务发现的RouteDefinitionLocator DiscoveryClientRouteDefinitionLocator是通过服务发现组件获取注册中心的服务，即路由定义的源变成了配置中心了，服务注册于发现组件配合负载均衡，这个在微服务架构中应该是很常用的组合，好处很多，如多实例部署负载均衡</description>
    </item>
    
    <item>
      <title>深入解析微服务网关Spring Cloud Gateway（十五）基于属性配置的RouteDefinitionLocator</title>
      <link>https://qingting-zheng.github.io:443/tech/2020-08/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3spring-cloud-gateway%E5%8D%81%E4%BA%94%E5%9F%BA%E4%BA%8E%E5%B1%9E%E6%80%A7%E9%85%8D%E7%BD%AE%E7%9A%84routedefinitionlocator/</link>
      <pubDate>Wed, 19 Aug 2020 10:01:15 +0800</pubDate>
      
      <guid>https://qingting-zheng.github.io:443/tech/2020-08/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3spring-cloud-gateway%E5%8D%81%E4%BA%94%E5%9F%BA%E4%BA%8E%E5%B1%9E%E6%80%A7%E9%85%8D%E7%BD%AE%E7%9A%84routedefinitionlocator/</guid>
      <description>系新的组件解析系列文章《微服务网关 Spring Cloud Gageway解析》的介绍与深入讲解。欢迎关注、转发、评论。 基于属性配置的RouteDefinitionLocator PropertiesRouteDefinitionLocator从类名就可以知道是从配置文件读取路由配置，如YAML、Properties等配置文件。 public class PropertiesRouteDefinitionLocator implements RouteDefinitionLocator { private final GatewayProperties properties; public PropertiesRouteDefinitionLocator(GatewayProperties properties) { this.properties = properties; } @Override public Flux&amp;lt;RouteDefinition&amp;gt; getRouteDefinitions() { return Flux.fromIterable(this.properties.getRoutes()); } } 实现很简单，通过构造函数传入的Gatew</description>
    </item>
    
    <item>
      <title>深入解析微服务网关Spring Cloud Gateway（十四）缓存方式的RouteDefinitionLocator</title>
      <link>https://qingting-zheng.github.io:443/tech/2020-08/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3spring-cloud-gateway%E5%8D%81%E5%9B%9B%E7%BC%93%E5%AD%98%E6%96%B9%E5%BC%8F%E7%9A%84routedefinitionlocator/</link>
      <pubDate>Tue, 18 Aug 2020 10:01:15 +0800</pubDate>
      
      <guid>https://qingting-zheng.github.io:443/tech/2020-08/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3spring-cloud-gateway%E5%8D%81%E5%9B%9B%E7%BC%93%E5%AD%98%E6%96%B9%E5%BC%8F%E7%9A%84routedefinitionlocator/</guid>
      <description>系新的组件解析系列文章《微服务网关 Spring Cloud Gageway解析》的介绍与深入讲解。欢迎关注、转发、评论。 缓存方式的RouteDefinitionLocator 该路由定义定位器结合了缓存，使用时需要传入具体的代理定位器，通过CAS操作获取完整的路由定义信息。 public class CachingRouteDefinitionLocator implements RouteDefinitionLocator { private final RouteDefinitionLocator delegate; private final AtomicReference&amp;lt;List&amp;lt;RouteDefinition&amp;gt;&amp;gt; cachedRoutes = new AtomicReference&amp;lt;&amp;gt;(); public CachingRouteDefinitionLocator(RouteDefinitionLocator delegate) { this.delegate = delegate; //原子类中提供的CAS操作，设置给定的更新值到当前值。 this.cachedRoutes.compareAndSet(null, collectRoutes()); } private List&amp;lt;RouteDefinition&amp;gt; collectRoutes() { return this.delegate.getRouteDefinitions().collectList().block(); } @Override public Flux&amp;lt;RouteDefinition&amp;gt; getRouteDefinitions() { return Flux.fromIterable(this.cachedRoutes.get()); } //... } 由于赋</description>
    </item>
    
    <item>
      <title>深入解析微服务网关Spring Cloud Gateway（十三）路由定义的数据访问操作</title>
      <link>https://qingting-zheng.github.io:443/tech/2020-08/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3spring-cloud-gateway%E5%8D%81%E4%B8%89%E8%B7%AF%E7%94%B1%E5%AE%9A%E4%B9%89%E7%9A%84%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Wed, 05 Aug 2020 10:01:15 +0800</pubDate>
      
      <guid>https://qingting-zheng.github.io:443/tech/2020-08/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3spring-cloud-gateway%E5%8D%81%E4%B8%89%E8%B7%AF%E7%94%B1%E5%AE%9A%E4%B9%89%E7%9A%84%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE%E6%93%8D%E4%BD%9C/</guid>
      <description>系新的组件解析系列文章《微服务网关 Spring Cloud Gageway解析》的介绍与深入讲解。欢迎关注、转发、评论。 路由定义的数据访问操作 RouteDefinitionRepository接口中的方法用于对RouteDefinition进行增、删、查操作。 public interface RouteDefinitionRepository extends RouteDefinitionLocator, RouteDefinitionWriter { } //RouteDefinitionWriter对路由定义进行操作 public interface RouteDefinitionWriter { Mono&amp;lt;Void&amp;gt; save(Mono&amp;lt;RouteDefinition&amp;gt; route); Mono&amp;lt;Void&amp;gt; delete(Mono&amp;lt;String&amp;gt; routeId); } 该接口继承了RouteDefinitionWriter，对路</description>
    </item>
    
    <item>
      <title>深入解析微服务网关Spring Cloud Gateway（十二）RouteDefinitionLocator与RouteDefinitionLocator </title>
      <link>https://qingting-zheng.github.io:443/tech/2020-07/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3spring-cloud-gateway%E5%8D%81%E4%BA%8Croutedefinitionlocator%E4%B8%8Eroutedefinitionlocator/</link>
      <pubDate>Tue, 14 Jul 2020 10:01:15 +0800</pubDate>
      
      <guid>https://qingting-zheng.github.io:443/tech/2020-07/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3spring-cloud-gateway%E5%8D%81%E4%BA%8Croutedefinitionlocator%E4%B8%8Eroutedefinitionlocator/</guid>
      <description>系新的组件解析系列文章《微服务网关 Spring Cloud Gageway解析》的介绍与深入讲解。欢迎关注、转发、评论。 路由定位器 直接获取路由的方法是通过RouteLocator接口获取。同样，该顶级接口有多个实现类，如下为RouteLocator的类图。 public interface RouteLocator { Flux&amp;lt;Route&amp;gt; getRoutes(); } 与上一节介绍的RouteDefinitionLocator接口类似，只有一个getRoutes方法用以获取路由信息。 public class Route implements Ordered { //路由Id private final String id; //</description>
    </item>
    
    <item>
      <title>深入解析微服务网关Spring Cloud Gateway（十一）缓存方式的 RouteDefinitionLocator</title>
      <link>https://qingting-zheng.github.io:443/tech/2020-07/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3spring-cloud-gateway%E5%8D%81%E4%B8%80%E7%BC%93%E5%AD%98%E6%96%B9%E5%BC%8F%E7%9A%84-routedefinitionlocator/</link>
      <pubDate>Fri, 03 Jul 2020 10:01:15 +0800</pubDate>
      
      <guid>https://qingting-zheng.github.io:443/tech/2020-07/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3spring-cloud-gateway%E5%8D%81%E4%B8%80%E7%BC%93%E5%AD%98%E6%96%B9%E5%BC%8F%E7%9A%84-routedefinitionlocator/</guid>
      <description>系新的组件解析系列文章《微服务网关 Spring Cloud Gageway解析》的介绍与深入讲解。欢迎关注、转发、评论。 组合的RouteDefinitionLocator CompositeRouteDefinitionLocator组合多种 RouteDefinitionLocator的实现，为 RouteDefinitionRouteLocator提供统一入口。代码如下： public class CompositeRouteDefinitionLocator implements RouteDefinitionLocator { private final Flux&amp;lt;RouteDefinitionLocator&amp;gt; delegates; public CompositeRouteDefinitionLocator(Flux&amp;lt;RouteDefinitionLocator&amp;gt; delegates) { this.delegates = delegates; } @Override public Flux&amp;lt;RouteDefinition&amp;gt; getRouteDefinitions() { return this.delegates.flatMap(RouteDefinitionLocator::getRouteDefinitions);</description>
    </item>
    
    <item>
      <title>深入解析微服务网关Spring Cloud Gateway（十）RouteDefinitionLocator与RouteDefinitionLocator </title>
      <link>https://qingting-zheng.github.io:443/tech/2020-06/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3spring-cloud-gateway%E5%8D%81routedefinitionlocator%E4%B8%8Eroutedefinitionlocator/</link>
      <pubDate>Mon, 29 Jun 2020 10:01:15 +0800</pubDate>
      
      <guid>https://qingting-zheng.github.io:443/tech/2020-06/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3spring-cloud-gateway%E5%8D%81routedefinitionlocator%E4%B8%8Eroutedefinitionlocator/</guid>
      <description>系新的组件解析系列文章《微服务网关 Spring Cloud Gageway解析》的介绍与深入讲解。欢迎关注、转发、评论。 基于属性配置的RouteDefinitionLocator PropertiesRouteDefinitionLocator从类名就可以知道是从配置文件读取路由配置，如YAML、Properties等配置文件。 public class PropertiesRouteDefinitionLocator implements RouteDefinitionLocator { private final GatewayProperties properties; public PropertiesRouteDefinitionLocator(GatewayProperties properties) { this.properties = properties; } @Override public Flux&amp;lt;RouteDefinition&amp;gt; getRouteDefinitions() { return Flux.fromIterable(this.properties.getRoutes()); } } 实现很简单，通过构造函数传入的Gatew</description>
    </item>
    
    <item>
      <title>深入解析微服务网关Spring Cloud Gateway（九）缓存方式的 RouteDefinitionLocator</title>
      <link>https://qingting-zheng.github.io:443/tech/2020-06/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3spring-cloud-gateway%E4%B9%9D%E7%BC%93%E5%AD%98%E6%96%B9%E5%BC%8F%E7%9A%84-routedefinitionlocator/</link>
      <pubDate>Sun, 07 Jun 2020 10:01:15 +0800</pubDate>
      
      <guid>https://qingting-zheng.github.io:443/tech/2020-06/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3spring-cloud-gateway%E4%B9%9D%E7%BC%93%E5%AD%98%E6%96%B9%E5%BC%8F%E7%9A%84-routedefinitionlocator/</guid>
      <description>系新的组件解析系列文章《微服务网关 Spring Cloud Gageway解析》的介绍与深入讲解。欢迎关注、转发、评论。 缓存方式的 RouteDefinitionLocator 该路由定义定位器结合了缓存，使用时需要传入具体的代理定位器，通过CAS操作获取完整的路由定义信息。 public class CachingRouteDefinitionLocator implements RouteDefinitionLocator { private final RouteDefinitionLocator delegate; private final AtomicReference&amp;lt;List&amp;lt;RouteDefinition&amp;gt;&amp;gt; cachedRoutes = new AtomicReference&amp;lt;&amp;gt;(); public CachingRouteDefinitionLocator(RouteDefinitionLocator delegate) { this.delegate = delegate; //原子类中提供的CAS操作，设置给定的更新值到当前值。 this.cachedRoutes.compareAndSet(null, collectRoutes()); } private List&amp;lt;RouteDefinition&amp;gt; collectRoutes() { return this.delegate.getRouteDefinitions().collectList().block(); } @Override public Flux&amp;lt;RouteDefinition&amp;gt; getRouteDefinitions() { return Flux.fromIterable(this.cachedRoutes.get()); } //... } 由于赋值操作不是线程安全的。若想不用锁来实现，可</description>
    </item>
    
    <item>
      <title>深入解析微服务网关Spring Cloud Gateway（八）路由定义定位器</title>
      <link>https://qingting-zheng.github.io:443/tech/2020-05/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3spring-cloud-gateway%E5%85%AB%E8%B7%AF%E7%94%B1%E5%AE%9A%E4%B9%89%E5%AE%9A%E4%BD%8D%E5%99%A8/</link>
      <pubDate>Tue, 19 May 2020 10:01:15 +0800</pubDate>
      
      <guid>https://qingting-zheng.github.io:443/tech/2020-05/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3spring-cloud-gateway%E5%85%AB%E8%B7%AF%E7%94%B1%E5%AE%9A%E4%B9%89%E5%AE%9A%E4%BD%8D%E5%99%A8/</guid>
      <description>系新的组件解析系列文章《微服务网关 Spring Cloud Gageway解析》的介绍与深入讲解。欢迎关注、转发、评论。 路由定义定位器 RouteDefinitionLocator是路由定义定位器的顶级接口，具体的路由定义定位器都继承自该接口，其类图如下。 public interface RouteDefinitionLocator { Flux&amp;lt;RouteDefinition&amp;gt; getRouteDefinitions(); } 可以看到定义了唯一一个方法，用以获取RouteDefinition。RouteDefinition对象作为属性定义在GatewayProperties中，</description>
    </item>
    
    <item>
      <title>深入解析微服务网关Spring Cloud Gateway（七）过滤器的web处理器</title>
      <link>https://qingting-zheng.github.io:443/tech/2020-05/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3spring-cloud-gateway%E4%B8%83%E8%BF%87%E6%BB%A4%E5%99%A8%E7%9A%84web%E5%A4%84%E7%90%86%E5%99%A8/</link>
      <pubDate>Sat, 02 May 2020 10:01:15 +0800</pubDate>
      
      <guid>https://qingting-zheng.github.io:443/tech/2020-05/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3spring-cloud-gateway%E4%B8%83%E8%BF%87%E6%BB%A4%E5%99%A8%E7%9A%84web%E5%A4%84%E7%90%86%E5%99%A8/</guid>
      <description>系新的组件解析系列文章《微服务网关 Spring Cloud Gageway解析》的介绍与深入讲解。欢迎关注、转发、评论。 过滤器的web处理器 FilteringWebHandler通过创建请求Route对应的 GatewayFilterChain 在网关处进行过滤处理。 public class FilteringWebHandler implements WebHandler { private final List&amp;lt;GatewayFilter&amp;gt; globalFilters; public FilteringWebHandler(List&amp;lt;GlobalFilter&amp;gt; globalFilters) { this.globalFilters = loadFilters(globalFilters); } private static List&amp;lt;GatewayFilter&amp;gt; loadFilters(List&amp;lt;GlobalFilter&amp;gt; filters) { return filters.stream() .map(filter -&amp;gt; { //适配器模式，用以适配GlobalFilter GatewayFilterAdapter gatewayFilter = new GatewayFilterAdapter(filter); //判断是否实现Ordered接口 if (filter instanceof Ordered) { //实现了Ordered接口，则</description>
    </item>
    
    <item>
      <title>深入解析微服务网关Spring Cloud Gateway（六）网关处理器</title>
      <link>https://qingting-zheng.github.io:443/tech/2020-04/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3spring-cloud-gateway%E5%85%AD%E7%BD%91%E5%85%B3%E5%A4%84%E7%90%86%E5%99%A8/</link>
      <pubDate>Sun, 19 Apr 2020 10:01:15 +0800</pubDate>
      
      <guid>https://qingting-zheng.github.io:443/tech/2020-04/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3spring-cloud-gateway%E5%85%AD%E7%BD%91%E5%85%B3%E5%A4%84%E7%90%86%E5%99%A8/</guid>
      <description>系新的组件解析系列文章《微服务网关 Spring Cloud Gageway解析》的介绍与深入讲解。欢迎关注、转发、评论。 网关处理器 请求到达网关之后，会有各种Web处理器对请求进行匹配与处理，下图为Spring Cloud Gateway中主要涉及到的WebHandler： DispatcherHandler -&amp;gt; RoutePredicateHandlerMapping -&amp;gt; FilteringWebHandler -&amp;gt; DefaultGatewayFilterChain 按照顺序，这一小节将会讲解前两个，负责对请求路由选择和定位。 请求的分发器 Spring Cloud Gateway 引入了Spring-webflux，DispatcherHandler</description>
    </item>
    
    <item>
      <title>深入解析微服务网关Spring Cloud Gateway（五）源码解析之初始化配置</title>
      <link>https://qingting-zheng.github.io:443/tech/2020-04/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3spring-cloud-gateway%E4%BA%94%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8B%E5%88%9D%E5%A7%8B%E5%8C%96%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Sun, 12 Apr 2020 10:01:15 +0800</pubDate>
      
      <guid>https://qingting-zheng.github.io:443/tech/2020-04/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3spring-cloud-gateway%E4%BA%94%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8B%E5%88%9D%E5%A7%8B%E5%8C%96%E9%85%8D%E7%BD%AE/</guid>
      <description>系新的组件解析系列文章《微服务网关 Spring Cloud Gageway解析》的介绍与深入讲解。欢迎关注、转发、评论。 源码解析 作为系统的统一入口，API网关可提供请求路由与组合、协议转换、安全认证、服务鉴权、流量控制与日志监控等服务。当企业将所有的应用使用微服务的架构管理起来，那么API网关就起到了微服务网关的作用。 而当企业只是将系统与系统之间的调用使用REST方式进行访问时使用API网关对调用进行管理，那么API网</description>
    </item>
    
    <item>
      <title>深入解析微服务网关Spring Cloud Gateway（四）网关的其他应用</title>
      <link>https://qingting-zheng.github.io:443/tech/2020-03/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3spring-cloud-gateway%E5%9B%9B%E7%BD%91%E5%85%B3%E7%9A%84%E5%85%B6%E4%BB%96%E5%BA%94%E7%94%A8/</link>
      <pubDate>Thu, 19 Mar 2020 10:01:15 +0800</pubDate>
      
      <guid>https://qingting-zheng.github.io:443/tech/2020-03/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3spring-cloud-gateway%E5%9B%9B%E7%BD%91%E5%85%B3%E7%9A%84%E5%85%B6%E4%BB%96%E5%BA%94%E7%94%A8/</guid>
      <description>系新的组件解析系列文章《微服务网关 Spring Cloud Gageway解析》的介绍与深入讲解。欢迎关注、转发、评论。 kotlin自定义路由 Spring Cloud Gateway可以使用kotlin自定义路由： @Configuration class AdditionalRoutes { @Bean fun additionalRouteLocator(builder: RouteLocatorBuilder): RouteLocator = builder.routes { route(id = &amp;#34;test-kotlin&amp;#34;) { path(&amp;#34;/image/png&amp;#34;) filters { addResponseHeader(&amp;#34;X-TestHeader&amp;#34;, &amp;#34;foobar&amp;#34;) } uri(&amp;#34;http://httpbin.org:80&amp;#34;) } } } 当请求的路径是/image/png，将会转发到http://httpbin.org:80，并设置了过滤器，在其响应头中加上了X-TestHeader: foobar头部。 websocket 还可以配</description>
    </item>
    
    <item>
      <title>深入解析微服务网关Spring Cloud Gateway（三）搭建网关</title>
      <link>https://qingting-zheng.github.io:443/tech/2020-03/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3spring-cloud-gateway%E4%B8%89%E6%90%AD%E5%BB%BA%E7%BD%91%E5%85%B3/</link>
      <pubDate>Mon, 02 Mar 2020 10:01:15 +0800</pubDate>
      
      <guid>https://qingting-zheng.github.io:443/tech/2020-03/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3spring-cloud-gateway%E4%B8%89%E6%90%AD%E5%BB%BA%E7%BD%91%E5%85%B3/</guid>
      <description>系新的组件解析系列文章《微服务网关 Spring Cloud Gageway解析》的介绍与深入讲解。欢迎关注、转发、评论。 网关服务 网关服务提供多种路由配置、路由断言工厂和过滤器工厂等功能。 依赖 需要引入的依赖： &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-actuator&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!--依赖于webflux，必须引入--&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-webflux&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-gateway-core&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!--服务发现组件，排除web依赖--&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-consul-discovery&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.0.0.M6&amp;lt;/version&amp;gt; &amp;lt;exclusions&amp;gt; &amp;lt;exclusion&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt; &amp;lt;/exclusion&amp;gt; &amp;lt;/exclusions&amp;gt; &amp;lt;/dependency&amp;gt; //kotlin依赖 &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.jetbrains.kotlin&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;kotlin-stdlib&amp;lt;/artifactId&amp;gt; &amp;lt;optional&amp;gt;true&amp;lt;/optional&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.jetbrains.kotlin&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;kotlin-reflect&amp;lt;/artifactId&amp;gt; &amp;lt;optional&amp;gt;true&amp;lt;/optional&amp;gt; &amp;lt;/dependency&amp;gt; 如上引入了kotli</description>
    </item>
    
    <item>
      <title>深入解析微服务网关Spring Cloud Gateway（二）快速入门</title>
      <link>https://qingting-zheng.github.io:443/tech/2020-02/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3spring-cloud-gateway%E4%BA%8C%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</link>
      <pubDate>Sun, 09 Feb 2020 10:01:15 +0800</pubDate>
      
      <guid>https://qingting-zheng.github.io:443/tech/2020-02/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3spring-cloud-gateway%E4%BA%8C%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</guid>
      <description>系新的组件解析系列文章《微服务网关 Spring Cloud Gageway解析》的介绍与深入讲解。欢迎关注、转发、评论。 基础应用 示例启动两个服务：Gateway-Server和User-Server。模拟的场景为，客户端请求后端服务，网关提供后端服务的统一入口。后端的服务都注册到服务发现Consul（搭建zk，Eureka都可以，笔者比较习惯使用Consul）。网关通过负载均衡转发到具体的后端服务。 用户服务 用户服务功能</description>
    </item>
    
    <item>
      <title>深入解析微服务网关Spring Cloud Gateway（一）总体概述</title>
      <link>https://qingting-zheng.github.io:443/tech/2020-02/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3spring-cloud-gateway%E4%B8%80%E6%80%BB%E4%BD%93%E6%A6%82%E8%BF%B0/</link>
      <pubDate>Tue, 04 Feb 2020 10:01:15 +0800</pubDate>
      
      <guid>https://qingting-zheng.github.io:443/tech/2020-02/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3spring-cloud-gateway%E4%B8%80%E6%80%BB%E4%BD%93%E6%A6%82%E8%BF%B0/</guid>
      <description>系新的组件解析系列文章《微服务网关 Spring Cloud Gageway解析》的介绍与深入讲解。欢迎关注、转发、评论。 当使用单体应用程序架构时，客户端（Web或移动端）通过向后端应用程序发起一次REST调用来获取数据。负载均衡器将请求路由给N个相同的应用程序实例中的一个。然后应用程序会查询各种数据库表，并将响应返回给客户端。微服务架构下，单体应用被切割成多个微服务，如果将所有的微服务直接对外暴露，势必会出现安全方面的</description>
    </item>
    
    <item>
      <title>深入解析负载均衡组件 Feign（完结）应用进阶之Decoder与Encoder的自定制化、日志记录与请求/响应压缩</title>
      <link>https://qingting-zheng.github.io:443/tech/2019-11/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%BB%84%E4%BB%B6-feign%E5%AE%8C%E7%BB%93%E5%BA%94%E7%94%A8%E8%BF%9B%E9%98%B6%E4%B9%8Bdecoder%E4%B8%8Eencoder%E7%9A%84%E8%87%AA%E5%AE%9A%E5%88%B6%E5%8C%96%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95%E4%B8%8E%E8%AF%B7%E6%B1%82/%E5%93%8D%E5%BA%94%E5%8E%8B%E7%BC%A9/</link>
      <pubDate>Sat, 16 Nov 2019 10:01:15 +0800</pubDate>
      
      <guid>https://qingting-zheng.github.io:443/tech/2019-11/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%BB%84%E4%BB%B6-feign%E5%AE%8C%E7%BB%93%E5%BA%94%E7%94%A8%E8%BF%9B%E9%98%B6%E4%B9%8Bdecoder%E4%B8%8Eencoder%E7%9A%84%E8%87%AA%E5%AE%9A%E5%88%B6%E5%8C%96%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95%E4%B8%8E%E8%AF%B7%E6%B1%82/%E5%93%8D%E5%BA%94%E5%8E%8B%E7%BC%A9/</guid>
      <description>系新的组件解析系列文章《Feign 解析》的介绍与深入讲解。欢迎关注、转发、评论。 Decoder与Encoder的自定制化 Encoder用于将Object对象转化为HTTP的请求Body，而Decoder用于将网络Response转化为对应的Object对象。Feign对于二者都提供了默认的实现，但是使用者可以根据自己的业务来选择其他的编解码方式。 我们只需要在自定义配置中给出Decoder和Enco</description>
    </item>
    
    <item>
      <title>深入解析负载均衡组件 Feign（十二）应用进阶之Client自定义</title>
      <link>https://qingting-zheng.github.io:443/tech/2019-11/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%BB%84%E4%BB%B6-feign%E5%8D%81%E4%BA%8C%E5%BA%94%E7%94%A8%E8%BF%9B%E9%98%B6%E4%B9%8Bclient%E8%87%AA%E5%AE%9A%E4%B9%89/</link>
      <pubDate>Mon, 04 Nov 2019 10:01:15 +0800</pubDate>
      
      <guid>https://qingting-zheng.github.io:443/tech/2019-11/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%BB%84%E4%BB%B6-feign%E5%8D%81%E4%BA%8C%E5%BA%94%E7%94%A8%E8%BF%9B%E9%98%B6%E4%B9%8Bclient%E8%87%AA%E5%AE%9A%E4%B9%89/</guid>
      <description>系新的组件解析系列文章《Feign 解析》的介绍与深入讲解。欢迎关注、转发、评论。 Client自定义 Spring Cloud Feign的核心概念之一就是各类命名的Client。每个feign client都是由一组可以协作向远程服务发送请求的组件构成。每个client都能通过@FeignClient注解提供一个名称。Spring Cloud通过FeignClientsConfiguration来为每个命名的client新建</description>
    </item>
    
    <item>
      <title>深入解析负载均衡组件 Feign（十一）函数调用和网络请求</title>
      <link>https://qingting-zheng.github.io:443/tech/2019-10/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%BB%84%E4%BB%B6-feign%E5%8D%81%E4%B8%80%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%92%8C%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/</link>
      <pubDate>Sun, 06 Oct 2019 10:01:15 +0800</pubDate>
      
      <guid>https://qingting-zheng.github.io:443/tech/2019-10/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%BB%84%E4%BB%B6-feign%E5%8D%81%E4%B8%80%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%92%8C%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/</guid>
      <description>系新的组件解析系列文章《Feign 解析》的介绍与深入讲解。欢迎关注、转发、评论。 函数调用和网络请求 在Feing配置和实例生成结束之后，我们就可以直接使用FeignClient的实例，并调用它的函数发送网络请求。在调用其函数的过程中，由于我们设置了MethodHandler，所以最终函数调用会执行到SynchronousMethodHandler的invoke方法。在该方法中Feign会将函数参数与</description>
    </item>
    
    <item>
      <title>深入解析负载均衡组件 Feign（十）实例初始化-续3</title>
      <link>https://qingting-zheng.github.io:443/tech/2019-10/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%BB%84%E4%BB%B6-feign%E5%8D%81%E5%AE%9E%E4%BE%8B%E5%88%9D%E5%A7%8B%E5%8C%96-%E7%BB%AD3/</link>
      <pubDate>Wed, 02 Oct 2019 10:01:15 +0800</pubDate>
      
      <guid>https://qingting-zheng.github.io:443/tech/2019-10/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%BB%84%E4%BB%B6-feign%E5%8D%81%E5%AE%9E%E4%BE%8B%E5%88%9D%E5%A7%8B%E5%8C%96-%E7%BB%AD3/</guid>
      <description>系新的组件解析系列文章《Feign 解析》的介绍与深入讲解。欢迎关注、转发、评论。 那我们就来看一下MethodHandler到底是如何处理这些函数调用的。前面文章中的FeignServiceClient.getInstanceByServiceId函数被调用时，Fegin是如何发送网络请求，并将结果返回的。SynchronousMethodHandler是如何将函数调用转换为网络调用的关键，这个部分</description>
    </item>
    
    <item>
      <title>深入解析负载均衡组件 Feign（九）实例初始化-续2</title>
      <link>https://qingting-zheng.github.io:443/tech/2019-09/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%BB%84%E4%BB%B6-feign%E4%B9%9D%E5%AE%9E%E4%BE%8B%E5%88%9D%E5%A7%8B%E5%8C%96-%E7%BB%AD2/</link>
      <pubDate>Thu, 26 Sep 2019 10:01:15 +0800</pubDate>
      
      <guid>https://qingting-zheng.github.io:443/tech/2019-09/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%BB%84%E4%BB%B6-feign%E4%B9%9D%E5%AE%9E%E4%BE%8B%E5%88%9D%E5%A7%8B%E5%8C%96-%E7%BB%AD2/</guid>
      <description>系新的组件解析系列文章《Feign 解析》的介绍与深入讲解。欢迎关注、转发、评论。 接着上一篇八，我们继续讲解动态注册BeanDefinition`。 @RequestMapping`在修饰FeignClient接口类时，其value所代表的值会被记录下来，它是该FeignClient下所有请求URL的前置路径。 //SpringMvcContract.java protected void processAnnotationOnClass(MethodMetadata data, Class&amp;lt;?&amp;gt; clz) { if (clz.getInterfaces().length == 0) { //获取RequestMapping的注解信息，并设置Method</description>
    </item>
    
    <item>
      <title>深入解析负载均衡组件 Feign（八）实例初始化-续1</title>
      <link>https://qingting-zheng.github.io:443/tech/2019-09/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%BB%84%E4%BB%B6-feign%E5%85%AB%E5%AE%9E%E4%BE%8B%E5%88%9D%E5%A7%8B%E5%8C%96-%E7%BB%AD1/</link>
      <pubDate>Tue, 17 Sep 2019 10:01:15 +0800</pubDate>
      
      <guid>https://qingting-zheng.github.io:443/tech/2019-09/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%BB%84%E4%BB%B6-feign%E5%85%AB%E5%AE%9E%E4%BE%8B%E5%88%9D%E5%A7%8B%E5%8C%96-%E7%BB%AD1/</guid>
      <description>系新的组件解析系列文章《Feign 解析》的介绍与深入讲解。欢迎关注、转发、评论。 由于实例化代码逻辑复杂，我们继续前面的内容。 当FeignClient的函数被调用时，InvocationHandler的回调函数会被调用，Feign会在其回调函数中发送网络请求。 public &amp;lt;T&amp;gt; T target(Target&amp;lt;T&amp;gt; target) { return build().newInstance(target); } public Feign build() { SynchronousMethodHandler.Factory synchronousMethodHandlerFactory = new SynchronousMethodHandler.Factory(client, retryer, requestInterceptors, logger, logLevel, decode404); ParseHandlersByName handlersByName = new ParseHandlersByName(contract, options, encoder, decoder, errorDecoder, synchronousMethodHandlerFactory); return new ReflectiveFeign(handlersByName, invocationHandlerFactory); } //ReflectiveFeign.java public &amp;lt;T&amp;gt; T newInstance(Target&amp;lt;T&amp;gt; target) { Map&amp;lt;String, MethodHandler&amp;gt; nameToHandler = targetToHandlersByName.apply(target); Map&amp;lt;Method, MethodHandler&amp;gt; methodToHandler = new LinkedHashMap&amp;lt;Method, MethodHandler&amp;gt;(); List&amp;lt;DefaultMethodHandler&amp;gt; defaultMethodHandlers = new LinkedList&amp;lt;DefaultMethodHandler&amp;gt;(); for (Method method : target.type().getMethods()) { if (method.getDeclaringClass() ==</description>
    </item>
    
    <item>
      <title>深入解析负载均衡组件 Feign（七）实例初始化</title>
      <link>https://qingting-zheng.github.io:443/tech/2019-08/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%BB%84%E4%BB%B6-feign%E4%B8%83%E5%AE%9E%E4%BE%8B%E5%88%9D%E5%A7%8B%E5%8C%96/</link>
      <pubDate>Mon, 19 Aug 2019 10:01:15 +0800</pubDate>
      
      <guid>https://qingting-zheng.github.io:443/tech/2019-08/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%BB%84%E4%BB%B6-feign%E4%B8%83%E5%AE%9E%E4%BE%8B%E5%88%9D%E5%A7%8B%E5%8C%96/</guid>
      <description>系新的组件解析系列文章《Feign 解析》的介绍与深入讲解。欢迎关注、转发、评论。 实例初始化 FeignClientFactoryBean是工厂类，Spring容器通过调用它的getObject函数来获取对应的Bean实例。由此，被@FeignClient修饰的接口类就可以被Spring容器实例化了。 public Object getObject() throws Exception { FeignContext context = applicationContext.getBean(FeignContext.class); Feign.Builder builder = feign(context); //如果url为空，则需要负载均衡 if (!StringUtils.hasText(this.url)) { String url; if (!this.name.startsWith(&amp;#34;http&amp;#34;)) { url = &amp;#34;http://&amp;#34; + this.name; } else { url = this.name; }</description>
    </item>
    
    <item>
      <title>深入解析负载均衡组件 Feign（六）动态注册BeanDefinition续</title>
      <link>https://qingting-zheng.github.io:443/tech/2019-08/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%BB%84%E4%BB%B6-feign%E5%85%AD%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8Cbeandefinition%E7%BB%AD/</link>
      <pubDate>Tue, 06 Aug 2019 10:01:15 +0800</pubDate>
      
      <guid>https://qingting-zheng.github.io:443/tech/2019-08/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%BB%84%E4%BB%B6-feign%E5%85%AD%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8Cbeandefinition%E7%BB%AD/</guid>
      <description>系新的组件解析系列文章《Feign 解析》的介绍与深入讲解。欢迎关注、转发、评论。 接着上一篇，我们继续讲解动态注册BeanDefinition`。 registerFeignClients函数中有一些实现上的细节值得大家认真了解并学习的，有利于大家对Spring框架的深度了解。首先是如何自定义Spring类扫描器。也就是如何使用ClassPathScanningCandidateComponentPr</description>
    </item>
    
    <item>
      <title>深入解析负载均衡组件 Feign（五）动态注册BeanDefinition</title>
      <link>https://qingting-zheng.github.io:443/tech/2019-07/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%BB%84%E4%BB%B6-feign%E4%BA%94%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8Cbeandefinition/</link>
      <pubDate>Tue, 09 Jul 2019 10:01:15 +0800</pubDate>
      
      <guid>https://qingting-zheng.github.io:443/tech/2019-07/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%BB%84%E4%BB%B6-feign%E4%BA%94%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8Cbeandefinition/</guid>
      <description>系新的组件解析系列文章《Feign 解析》的介绍与深入讲解。欢迎关注、转发、评论。 动态注册BeanDefinition Feign可以通过多种方式进行自定义配置，配置的变化会导致接口类初始化时使用不同的实现类，从而控制Feign的相关行为，比如说网络请求的编解码，压缩和日志处理。可以说，了解Feign配置和实例初始化的流程和原理对于我们学习和使用Feign有着至关重要的作用，而且Spring Cloud</description>
    </item>
    
    <item>
      <title>深入解析负载均衡组件 Feign（四）核心组件</title>
      <link>https://qingting-zheng.github.io:443/tech/2019-07/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%BB%84%E4%BB%B6-feign%E5%9B%9B%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/</link>
      <pubDate>Sat, 06 Jul 2019 10:01:15 +0800</pubDate>
      
      <guid>https://qingting-zheng.github.io:443/tech/2019-07/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%BB%84%E4%BB%B6-feign%E5%9B%9B%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/</guid>
      <description>系新的组件解析系列文章《Feign 解析》的介绍与深入讲解。欢迎关注、转发、评论。 核心组件与概念 读者在阅读Feign源码时，可以沿着两条路线进行，一是FeignServiceClient这样的被@FeignClient修饰的接口类如何被创建出来，也就是其Bean对象是如何被构建的，二是调用FeignServiceClient对象的响应方法时，Feign是如何发送网络请求的。而Feign相关的类也可以</description>
    </item>
    
    <item>
      <title>深入解析负载均衡组件 Feign（三）快速入门-服务消费者</title>
      <link>https://qingting-zheng.github.io:443/tech/2019-06/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%BB%84%E4%BB%B6-feign%E4%B8%89%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8-%E6%9C%8D%E5%8A%A1%E6%B6%88%E8%B4%B9%E8%80%85/</link>
      <pubDate>Sun, 09 Jun 2019 10:01:15 +0800</pubDate>
      
      <guid>https://qingting-zheng.github.io:443/tech/2019-06/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%BB%84%E4%BB%B6-feign%E4%B8%89%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8-%E6%9C%8D%E5%8A%A1%E6%B6%88%E8%B4%B9%E8%80%85/</guid>
      <description>系新的组件解析系列文章《Feign 解析》的介绍与深入讲解。欢迎关注、转发、评论。 服务消费者 Feign是声明式RESTful客户端，所以构建Feign项目的关键在于构建服务消费者。通过下面六步可以创建一个Spring Cloud Feign的服务消费者。 第一步: 创建普通的Spring Boot工程 首先创建一个普通的Spring Boot工程，取名为chapter-feign-client。 第二步：添加依赖 需要在po</description>
    </item>
    
    <item>
      <title>深入解析负载均衡组件 Feign（二）快速入门</title>
      <link>https://qingting-zheng.github.io:443/tech/2019-06/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%BB%84%E4%BB%B6-feign%E4%BA%8C%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</link>
      <pubDate>Sat, 01 Jun 2019 10:01:15 +0800</pubDate>
      
      <guid>https://qingting-zheng.github.io:443/tech/2019-06/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%BB%84%E4%BB%B6-feign%E4%BA%8C%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</guid>
      <description>系新的组件解析系列文章《Feign 解析》的介绍与深入讲解。欢迎关注、转发、评论。 服务注册中心 Feign可以配合eureka等服务注册中心同时使用。eureka来作为服务注册中心，为Feign提供关于服务端信息的获取，比如说IP地址。关于eureka的具体使用可以参考第四章中关于eureka的快速入门介绍。 服务提供者 Spring Cloud Feign是声明式RESTful请求客户端，所以它不会侵入服务提供者程序的实现。</description>
    </item>
    
    <item>
      <title>深入解析负载均衡组件 Feign（一）总体介绍</title>
      <link>https://qingting-zheng.github.io:443/tech/2019-05/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%BB%84%E4%BB%B6-feign%E4%B8%80%E6%80%BB%E4%BD%93%E4%BB%8B%E7%BB%8D/</link>
      <pubDate>Sat, 11 May 2019 10:01:15 +0800</pubDate>
      
      <guid>https://qingting-zheng.github.io:443/tech/2019-05/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%BB%84%E4%BB%B6-feign%E4%B8%80%E6%80%BB%E4%BD%93%E4%BB%8B%E7%BB%8D/</guid>
      <description>系新的组件解析系列文章《Feign 解析》的介绍与深入讲解。欢迎关注、转发、评论。 微服务之间的交互 微服务是软件系统架构上的一种设计风格，它倡导将一个原本独立的服务系统分成多个小型服务，这些小型服务都在独立的进程中运行，通过各个小型服务之间的协作来实现原本独立系统的所有业务功能。小型服务基于多种跨进程的方式进行通信协作，而在Spring Cloud架构中比较常见的跨进程的方式是RESTful HTTP请求</description>
    </item>
    
    <item>
      <title>深入解析负载均衡组件 Ribbon（十三）完结</title>
      <link>https://qingting-zheng.github.io:443/tech/2019-05/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%BB%84%E4%BB%B6-ribbon%E5%8D%81%E4%B8%89%E5%AE%8C%E7%BB%93/</link>
      <pubDate>Wed, 01 May 2019 10:01:15 +0800</pubDate>
      
      <guid>https://qingting-zheng.github.io:443/tech/2019-05/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%BB%84%E4%BB%B6-ribbon%E5%8D%81%E4%B8%89%E5%AE%8C%E7%BB%93/</guid>
      <description>系列文章《Ribbon 解析》的介绍与深入讲解。欢迎关注、转发、评论。 只读数据库的负载均衡实现 读者在学习了FeignLoadBalancer的原理和Ribbon的API之后，可以为任何需要负载均衡策略的项目添加Ribbon的集成。 比如一个的数据库中间件项目，它支持多个读库的数据读取，它希望对多个的读库进行数据读取时可以支持一定的负载均衡策略。那么，读者就可以通过集成Ribbon来实现读库之间的负载均</description>
    </item>
    
    <item>
      <title>深入解析负载均衡组件 Ribbon（十二）使用Netty发送网络请求</title>
      <link>https://qingting-zheng.github.io:443/tech/2019-04/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%BB%84%E4%BB%B6-ribbon%E5%8D%81%E4%BA%8C%E4%BD%BF%E7%94%A8netty%E5%8F%91%E9%80%81%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/</link>
      <pubDate>Sat, 27 Apr 2019 10:01:15 +0800</pubDate>
      
      <guid>https://qingting-zheng.github.io:443/tech/2019-04/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%BB%84%E4%BB%B6-ribbon%E5%8D%81%E4%BA%8C%E4%BD%BF%E7%94%A8netty%E5%8F%91%E9%80%81%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/</guid>
      <description>系列文章《Ribbon 解析》的介绍与深入讲解。欢迎关注、转发、评论。 使用Netty发送网络请求 Ribbon除了可以和RestTemplate，Feign一起使用之外，还可以与Netty进行集成，也就是说，Ribbon使用负载均衡策略选择完服务器之后，然后再交给Netty进行网络请求。 其实，上一小节的介绍的Ribbon的LoadBalancerCommand的submit函数可以直接使用Netty框</description>
    </item>
    
    <item>
      <title>深入解析负载均衡组件 Ribbon（十一）应用进阶之Ribbon API</title>
      <link>https://qingting-zheng.github.io:443/tech/2019-04/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%BB%84%E4%BB%B6-ribbon%E5%8D%81%E4%B8%80%E5%BA%94%E7%94%A8%E8%BF%9B%E9%98%B6%E4%B9%8Bribbon-api/</link>
      <pubDate>Wed, 10 Apr 2019 10:01:15 +0800</pubDate>
      
      <guid>https://qingting-zheng.github.io:443/tech/2019-04/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%BB%84%E4%BB%B6-ribbon%E5%8D%81%E4%B8%80%E5%BA%94%E7%94%A8%E8%BF%9B%E9%98%B6%E4%B9%8Bribbon-api/</guid>
      <description>系列文章《Ribbon 解析》的介绍与深入讲解。欢迎关注、转发、评论。 本节主要有关Ribbon的高级应用，主要有Ribbon的API使用，底层网络请求层的实现，和为已有spring系统集成Ribbon功能。 Ribbon API Ribbon除了与RestTemplate和Fegin一同使用之外，还可以依靠自己独立的API接口来实现一定的代码逻辑。 比如下面的代码中，使用LoadBalancerBuilder的build</description>
    </item>
    
    <item>
      <title>深入解析负载均衡组件 Ribbon（十）ServerListFilter 服务列表过滤</title>
      <link>https://qingting-zheng.github.io:443/tech/2019-03/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%BB%84%E4%BB%B6-ribbon%E5%8D%81serverlistfilter-%E6%9C%8D%E5%8A%A1%E5%88%97%E8%A1%A8%E8%BF%87%E6%BB%A4/</link>
      <pubDate>Mon, 04 Mar 2019 10:01:15 +0800</pubDate>
      
      <guid>https://qingting-zheng.github.io:443/tech/2019-03/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%BB%84%E4%BB%B6-ribbon%E5%8D%81serverlistfilter-%E6%9C%8D%E5%8A%A1%E5%88%97%E8%A1%A8%E8%BF%87%E6%BB%A4/</guid>
      <description>系列文章《Ribbon 解析》的介绍与深入讲解。欢迎关注、转发、评论。 服务列表 DomainExtractingServerList的getInitialListOfServers的实现十分简单，就是直接返回从Eureka中获取的服务器列表。 @Override public List&amp;lt;DiscoveryEnabledServer&amp;gt; getInitialListOfServers() { List&amp;lt;DiscoveryEnabledServer&amp;gt; servers = setZones(this.list .getInitialListOfServers()); return servers; } @Override public List&amp;lt;DiscoveryEnabledServer&amp;gt; getUpdatedListOfServers() { List&amp;lt;DiscoveryEnabledServer&amp;gt; servers = setZones(this.list .getUpdatedListOfServers()); return servers; } //添加zone相关的信息 private List&amp;lt;DiscoveryEnabledServer&amp;gt; setZones(List&amp;lt;DiscoveryEnabledServer&amp;gt; servers) { List&amp;lt;DiscoveryEnabledServer&amp;gt; result = new ArrayList&amp;lt;&amp;gt;(); //判断是否secure和是否使用ip地址 boolean isSecure = this.clientConfig.getPropertyAsBoolean( CommonClientConfigKey.IsSecure, Boolean.TRUE); boolean shouldUseIpAddr = this.clientConfig.getPropertyAsBoolean( CommonClientConfigKey.UseIPAddrForServer,</description>
    </item>
    
    <item>
      <title>深入解析负载均衡组件 Ribbon（九）IPing与server列表</title>
      <link>https://qingting-zheng.github.io:443/tech/2019-02/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%BB%84%E4%BB%B6-ribbon%E4%B9%9Diping%E4%B8%8Eserver%E5%88%97%E8%A1%A8/</link>
      <pubDate>Fri, 22 Feb 2019 10:01:15 +0800</pubDate>
      
      <guid>https://qingting-zheng.github.io:443/tech/2019-02/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%BB%84%E4%BB%B6-ribbon%E4%B9%9Diping%E4%B8%8Eserver%E5%88%97%E8%A1%A8/</guid>
      <description>系列文章《Ribbon 解析》的介绍与深入讲解。欢迎关注、转发、评论。 IPing IPing是Ribbon用来定义检查server是否可用的接口。 public interface IPing { //检查server是否可用。 public boolean isAlive(Server server); } Ribbon默认提供IPing接口的实现类是DummyPing。其实它并没有去真正的判断server是否是可用的，而是直接返回了true。 public class DummyPing extends AbstractLoadBalancerPing { public DummyPing() { } public boolean isAlive(Server server) { return true; } @Override public void initWithNiwsConfig(IClientConfig clientConfig) { } } 除了DummyPing之外，</description>
    </item>
    
    <item>
      <title>深入解析负载均衡组件 Ribbon（八）负载均衡策略实现</title>
      <link>https://qingting-zheng.github.io:443/tech/2019-02/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%BB%84%E4%BB%B6-ribbon%E5%85%AB%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Wed, 06 Feb 2019 10:01:15 +0800</pubDate>
      
      <guid>https://qingting-zheng.github.io:443/tech/2019-02/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%BB%84%E4%BB%B6-ribbon%E5%85%AB%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5%E5%AE%9E%E7%8E%B0/</guid>
      <description>系列文章《Ribbon 解析》的介绍与深入讲解。欢迎关注、转发、评论。 负载均衡策略实现 IRule是定义Ribbon负载均衡策略的接口，你可以通过实现该接口来自定义自己的负载均衡策略。该接口的默认Bean实例在RibbonClientConfiguration中给出。IRule接口的choose函数就是从一堆服务器中根据一定规则选出一个服务器。IRule有很多默认的实现类，这些实现类根据不同的算法和逻</description>
    </item>
    
    <item>
      <title>深入解析负载均衡组件 Ribbon（七）ILoadBalancer</title>
      <link>https://qingting-zheng.github.io:443/tech/2019-02/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%BB%84%E4%BB%B6-ribbon%E4%B8%83iloadbalancer/</link>
      <pubDate>Mon, 04 Feb 2019 10:01:15 +0800</pubDate>
      
      <guid>https://qingting-zheng.github.io:443/tech/2019-02/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%BB%84%E4%BB%B6-ribbon%E4%B8%83iloadbalancer/</guid>
      <description>系列文章《Ribbon 解析》的介绍与深入讲解。欢迎关注、转发、评论。 ILoadBalancer ILoadBalancer是RIbbon的关键类之一，它是定义软负载均衡操作过程的接口。 在上一小节中，读者应该已经了解到可以通过SpringClientFactory工厂类的getLoadBalancer函数获取ILoadBalancer实例。根据Ribbon的实例化机制，ILoadBalnacer实例是在RibbonAutoC</description>
    </item>
    
    <item>
      <title>深入解析负载均衡组件 Ribbon（六）LoadBalancerClient</title>
      <link>https://qingting-zheng.github.io:443/tech/2019-01/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%BB%84%E4%BB%B6-ribbon%E5%85%ADloadbalancerclient/</link>
      <pubDate>Sun, 27 Jan 2019 10:01:15 +0800</pubDate>
      
      <guid>https://qingting-zheng.github.io:443/tech/2019-01/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%BB%84%E4%BB%B6-ribbon%E5%85%ADloadbalancerclient/</guid>
      <description>系列文章《Ribbon 解析》的介绍与深入讲解。欢迎关注、转发、评论。 LoadBalancerClient 通过之前两个小节的讲述，相信读者已经对Ribbon与RestTemplate和Feign之间的工作原理有了一定的了解。接下来，本小节会对LoadBalancerClient进行负载均衡的具体原理和实现。 LoadBalancerClient是Ribbon项目的核心类之一，可以在RestTemplate发送网络请求时替代RestTe</description>
    </item>
    
    <item>
      <title>深入解析负载均衡组件 Ribbon（五） 和Feign一起使用</title>
      <link>https://qingting-zheng.github.io:443/tech/2019-01/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%BB%84%E4%BB%B6-ribbon%E4%BA%94-%E5%92%8Cfeign%E4%B8%80%E8%B5%B7%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Wed, 16 Jan 2019 10:01:15 +0800</pubDate>
      
      <guid>https://qingting-zheng.github.io:443/tech/2019-01/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%BB%84%E4%BB%B6-ribbon%E4%BA%94-%E5%92%8Cfeign%E4%B8%80%E8%B5%B7%E4%BD%BF%E7%94%A8/</guid>
      <description>系列文章《Ribbon 解析》的介绍与深入讲解。欢迎关注、转发、评论。 和Feign一起使用 Ribbon除了显示的和RestTemplate一起使用之外，还会是Feign有关负载均衡的默认实现。 在前面的文章有关Feign的中讲解了Feign相关实例的初始化过程。FeignClientFactoryBean是创造FeignClient的工厂类。在其getObject方法中有一个分支判断，如果请求URL不</description>
    </item>
    
    <item>
      <title>深入解析负载均衡组件 Ribbon（四）和RestTemplate一起使用</title>
      <link>https://qingting-zheng.github.io:443/tech/2019-01/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%BB%84%E4%BB%B6-ribbon%E5%9B%9B%E5%92%8Cresttemplate%E4%B8%80%E8%B5%B7%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Fri, 04 Jan 2019 10:01:15 +0800</pubDate>
      
      <guid>https://qingting-zheng.github.io:443/tech/2019-01/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%BB%84%E4%BB%B6-ribbon%E5%9B%9B%E5%92%8Cresttemplate%E4%B8%80%E8%B5%B7%E4%BD%BF%E7%94%A8/</guid>
      <description>系列文章《Ribbon 解析》的介绍与深入讲解。欢迎关注、转发、评论。 和RestTemplate一起使用 在前面快速入门一节中已经说明了Ribbon和RestTemplate之间的关系，而使二者产生联系的就是@LoadBalanced注解。@LoadBalanced是一个标记注解，可以表明被修饰的RestTemplate应该使用RibbonLoadBalancerClient来发送HTTP请求。Rib</description>
    </item>
    
    <item>
      <title>深入解析负载均衡组件 Ribbon（三）源码解析之配置和实例初始化</title>
      <link>https://qingting-zheng.github.io:443/tech/2018-12/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%BB%84%E4%BB%B6-ribbon%E4%B8%89%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8B%E9%85%8D%E7%BD%AE%E5%92%8C%E5%AE%9E%E4%BE%8B%E5%88%9D%E5%A7%8B%E5%8C%96/</link>
      <pubDate>Thu, 27 Dec 2018 10:01:15 +0800</pubDate>
      
      <guid>https://qingting-zheng.github.io:443/tech/2018-12/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%BB%84%E4%BB%B6-ribbon%E4%B8%89%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8B%E9%85%8D%E7%BD%AE%E5%92%8C%E5%AE%9E%E4%BE%8B%E5%88%9D%E5%A7%8B%E5%8C%96/</guid>
      <description>系列文章《Ribbon 解析》的介绍与深入讲解。欢迎关注、转发、评论。 配置和实例初始化 @RibbonClient用来声明Ribbon Client，用来声明Ribbon client的名称和配置，标记一个@Configuration的配置类，进行Ribbon相关的配置。@RibbonClient还会importRibbonClientConfigurationRegistrar类来进行动态的BeanDe</description>
    </item>
    
    <item>
      <title>深入解析负载均衡组件 Ribbon（二）快速入门</title>
      <link>https://qingting-zheng.github.io:443/tech/2018-12/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%BB%84%E4%BB%B6-ribbon%E4%BA%8C%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</link>
      <pubDate>Wed, 26 Dec 2018 10:01:15 +0800</pubDate>
      
      <guid>https://qingting-zheng.github.io:443/tech/2018-12/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%BB%84%E4%BB%B6-ribbon%E4%BA%8C%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</guid>
      <description>系列文章《Ribbon 解析》的介绍与深入讲解。欢迎关注、转发、评论。 快速入门 Ribbon可以和RestTemplate一起使用，也可以集成到Feign中使用。下面两小结将会分别讲述Ribbon在这两种使用方法下的示例。 RestTemplate是Spring的同步客户端HTTP请求接口，它可以简化客户端与HTTP服务器之间的交互，并且它强制使用RESTful风格，它会处理HTTP连接，只需要使用者提</description>
    </item>
    
    <item>
      <title>深入解析负载均衡组件 Ribbon（一）总体介绍</title>
      <link>https://qingting-zheng.github.io:443/tech/2018-12/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%BB%84%E4%BB%B6-ribbon%E4%B8%80%E6%80%BB%E4%BD%93%E4%BB%8B%E7%BB%8D/</link>
      <pubDate>Thu, 06 Dec 2018 10:01:15 +0800</pubDate>
      
      <guid>https://qingting-zheng.github.io:443/tech/2018-12/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%BB%84%E4%BB%B6-ribbon%E4%B8%80%E6%80%BB%E4%BD%93%E4%BB%8B%E7%BB%8D/</guid>
      <description>系列文章《Ribbon 解析》的介绍与深入讲解。欢迎关注、转发、评论。 Ribbon是一个可以管理Http和TCP客户端的客户端负载均衡器。Feign已经在使用Ribbon了，如果你使用过@FeignClient,那么Ribbon也会被使用。 Ribbon的核心思想就是named client，也就是带有名称的Ribbon Client。每个Client由可配置的组件构成，负责一类服务的调用请求。Sprin</description>
    </item>
    
    <item>
      <title>服务发现：Spring Cloud Netflix Eureka （完结） 高可用性服务注册中心(Eureka服务端集群)</title>
      <link>https://qingting-zheng.github.io:443/tech/2018-11/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0spring-cloud-netflix-eureka-%E5%AE%8C%E7%BB%93-%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83eureka%E6%9C%8D%E5%8A%A1%E7%AB%AF%E9%9B%86%E7%BE%A4/</link>
      <pubDate>Mon, 26 Nov 2018 10:01:15 +0800</pubDate>
      
      <guid>https://qingting-zheng.github.io:443/tech/2018-11/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0spring-cloud-netflix-eureka-%E5%AE%8C%E7%BB%93-%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83eureka%E6%9C%8D%E5%8A%A1%E7%AB%AF%E9%9B%86%E7%BE%A4/</guid>
      <description>系列文章《Spring Cloud Netflix Eureka》的介绍与深入讲解。欢迎关注、转发、评论。 高可用性服务注册中心(Eureka服务端集群) Eureka Server可以变得更有弹性和高可用性，通过部署多个注册中心的实例，并让它们之间互相注册。在Standalone模式中，只能依赖Server和Client之间的缓存以及需要弹性的机制保证Server实例一直存活，单例的注册中心崩了，Client之间就很难互相发现和调用。 在</description>
    </item>
    
    <item>
      <title>服务发现：Spring Cloud Netflix Eureka （二十四）应用进阶之服务端配置</title>
      <link>https://qingting-zheng.github.io:443/tech/2018-11/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0spring-cloud-netflix-eureka-%E4%BA%8C%E5%8D%81%E5%9B%9B%E5%BA%94%E7%94%A8%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%9C%8D%E5%8A%A1%E7%AB%AF%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Tue, 06 Nov 2018 10:01:15 +0800</pubDate>
      
      <guid>https://qingting-zheng.github.io:443/tech/2018-11/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0spring-cloud-netflix-eureka-%E4%BA%8C%E5%8D%81%E5%9B%9B%E5%BA%94%E7%94%A8%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%9C%8D%E5%8A%A1%E7%AB%AF%E9%85%8D%E7%BD%AE/</guid>
      <description>系列文章《Spring Cloud Netflix Eureka》的介绍与深入讲解。欢迎关注、转发、评论。 Eureka Server也是一个Eureka Client，但在此处我们更关心Eureka Server内相关配置，该部分配置主要位于EurekaServerConfigBean，但是Eureka Server中作为一个可开箱即用服务注册中心，一般不建议修改默认的Server配置(Eureka Server中有部分根据ServerCon</description>
    </item>
    
    <item>
      <title>服务发现：Spring Cloud Netflix Eureka （二十三）应用进阶之客户端配置</title>
      <link>https://qingting-zheng.github.io:443/tech/2018-10/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0spring-cloud-netflix-eureka-%E4%BA%8C%E5%8D%81%E4%B8%89%E5%BA%94%E7%94%A8%E8%BF%9B%E9%98%B6%E4%B9%8B%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Tue, 16 Oct 2018 10:01:15 +0800</pubDate>
      
      <guid>https://qingting-zheng.github.io:443/tech/2018-10/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0spring-cloud-netflix-eureka-%E4%BA%8C%E5%8D%81%E4%B8%89%E5%BA%94%E7%94%A8%E8%BF%9B%E9%98%B6%E4%B9%8B%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%85%8D%E7%BD%AE/</guid>
      <description>系列文章《Spring Cloud Netflix Eureka》的介绍与深入讲解。欢迎关注、转发、评论。 配置详解 通过上一大节的源码的分析，相信对Eureka的运行机制已经有了进一步的了解。现在需要对Eureka的相关配置进行了解。首先会对Eureka中的大部分属性进行介绍，然后根据需要着重介绍一些关键的配置使用 Eureka在spring-cloud中主要靠3个配置类进行实现默认配置，EurekaClientConfigB</description>
    </item>
    
    <item>
      <title>服务发现：Spring Cloud Netflix Eureka （二十二）PeerEurekaNodes Server 对等集群</title>
      <link>https://qingting-zheng.github.io:443/tech/2018-10/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0spring-cloud-netflix-eureka-%E4%BA%8C%E5%8D%81%E4%BA%8Cpeereurekanodes-server-%E5%AF%B9%E7%AD%89%E9%9B%86%E7%BE%A4/</link>
      <pubDate>Tue, 02 Oct 2018 10:01:15 +0800</pubDate>
      
      <guid>https://qingting-zheng.github.io:443/tech/2018-10/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0spring-cloud-netflix-eureka-%E4%BA%8C%E5%8D%81%E4%BA%8Cpeereurekanodes-server-%E5%AF%B9%E7%AD%89%E9%9B%86%E7%BE%A4/</guid>
      <description>系列文章《Spring Cloud Netflix Eureka》的介绍与深入讲解。欢迎关注、转发、评论。 同步冲突 对于Eureka Server之间的HTTP以及批任务流交互过程，在此不多关注，有兴趣的读者可以细细去研读代码了解一下。以下需要在意的是Eureka Server在接受到对应的同步复制请求后如何修改自身的注册表信息，以及反馈给发起同步复制请求的Eureka Server。 这里首先明确一个概念，InstanceInfo</description>
    </item>
    
    <item>
      <title>服务发现：Spring Cloud Netflix Eureka （二十一）Eureka Server之间的注册表信息的同步复制</title>
      <link>https://qingting-zheng.github.io:443/tech/2018-09/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0spring-cloud-netflix-eureka-%E4%BA%8C%E5%8D%81%E4%B8%80eureka-server%E4%B9%8B%E9%97%B4%E7%9A%84%E6%B3%A8%E5%86%8C%E8%A1%A8%E4%BF%A1%E6%81%AF%E7%9A%84%E5%90%8C%E6%AD%A5%E5%A4%8D%E5%88%B6/</link>
      <pubDate>Wed, 19 Sep 2018 10:01:15 +0800</pubDate>
      
      <guid>https://qingting-zheng.github.io:443/tech/2018-09/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0spring-cloud-netflix-eureka-%E4%BA%8C%E5%8D%81%E4%B8%80eureka-server%E4%B9%8B%E9%97%B4%E7%9A%84%E6%B3%A8%E5%86%8C%E8%A1%A8%E4%BF%A1%E6%81%AF%E7%9A%84%E5%90%8C%E6%AD%A5%E5%A4%8D%E5%88%B6/</guid>
      <description>系列文章《Spring Cloud Netflix Eureka》的介绍与深入讲解。欢迎关注、转发、评论。 Server之间的注册表信息的同步复制 在PeerAwareInstanceRegistryImpl中，对Abstractinstanceregistry中的register()、cancel()、renew()等方法都添加了同步到PeerEurekaNode的操作，使Server集群中的注册表保持最终一致性。 @Override public boolean cancel(final String</description>
    </item>
    
    <item>
      <title>服务发现：Spring Cloud Netflix Eureka （十九）Eureka Server集群同步</title>
      <link>https://qingting-zheng.github.io:443/tech/2018-08/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0spring-cloud-netflix-eureka-%E5%8D%81%E4%B9%9Deureka-server%E9%9B%86%E7%BE%A4%E5%90%8C%E6%AD%A5/</link>
      <pubDate>Tue, 28 Aug 2018 10:01:15 +0800</pubDate>
      
      <guid>https://qingting-zheng.github.io:443/tech/2018-08/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0spring-cloud-netflix-eureka-%E5%8D%81%E4%B9%9Deureka-server%E9%9B%86%E7%BE%A4%E5%90%8C%E6%AD%A5/</guid>
      <description>系列文章《Spring Cloud Netflix Eureka》的介绍与深入讲解。欢迎关注、转发、评论。 在Eureka Server启动的过程中(EurekaBootStrap)，会进行initEurekaEnvironment()以及initEurekaServerContext()，initEurekaEnvironment()方法中初始化各种环境变量，在此不多加关注，在initEurekaServerContext(</description>
    </item>
    
    <item>
      <title>服务发现：Spring Cloud Netflix Eureka （二十）PeerEurekaNodes Server 对等集群</title>
      <link>https://qingting-zheng.github.io:443/tech/2018-08/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0spring-cloud-netflix-eureka-%E4%BA%8C%E5%8D%81peereurekanodes-server-%E5%AF%B9%E7%AD%89%E9%9B%86%E7%BE%A4/</link>
      <pubDate>Sat, 04 Aug 2018 10:01:15 +0800</pubDate>
      
      <guid>https://qingting-zheng.github.io:443/tech/2018-08/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0spring-cloud-netflix-eureka-%E4%BA%8C%E5%8D%81peereurekanodes-server-%E5%AF%B9%E7%AD%89%E9%9B%86%E7%BE%A4/</guid>
      <description>系列文章《Spring Cloud Netflix Eureka》的介绍与深入讲解。欢迎关注、转发、评论。 PeerEurekaNodes Server 对等集群 PeerEurekaNodes中管理PeerEurekaNode的集合，每一个PeerEurekaNode代表的就是一个可同步共享数据的Eureka Server。在PeerEurekaNode中，具有register()、cancel()、heartbeat()、statusUpdate()等诸多用于向pe</description>
    </item>
    
    <item>
      <title>服务发现：Spring Cloud Netflix Eureka （十八） Eureka Server 自我保护</title>
      <link>https://qingting-zheng.github.io:443/tech/2018-08/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0spring-cloud-netflix-eureka-%E5%8D%81%E5%85%AB-eureka-server-%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4/</link>
      <pubDate>Sat, 04 Aug 2018 10:01:15 +0800</pubDate>
      
      <guid>https://qingting-zheng.github.io:443/tech/2018-08/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0spring-cloud-netflix-eureka-%E5%8D%81%E5%85%AB-eureka-server-%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4/</guid>
      <description>系列文章《Spring Cloud Netflix Eureka》的介绍与深入讲解。欢迎关注、转发、评论。 自我保护 在上面的解析中，多次提到过了自我保护机制，下面对此作一定的补充介绍。 以下是euerka官网中对自我保护的描述： In Netflix, the above safeguard is called as self-preservation mode and is primarily used as a protection in scenarios where there is a network partition between a group of clients and the Eureka Server. In these scenarios, the server tries to protect the information it already has. There may be scenarios in case of a mass outage that this may cause the clients to get the instances that do not exist anymore. The clients must make sure they are resilient to eureka server returning an instance that is non-existent or un-responsive. The best protection in these scenarios is to timeout quickly</description>
    </item>
    
    <item>
      <title>每周Paper精读(2) Sentence Representation系列泛读</title>
      <link>https://qingting-zheng.github.io:443/tech/2018-07/%E6%AF%8F%E5%91%A8paper%E7%B2%BE%E8%AF%BB2-sentence-representation%E7%B3%BB%E5%88%97%E6%B3%9B%E8%AF%BB/</link>
      <pubDate>Mon, 30 Jul 2018 17:41:23 +0800</pubDate>
      
      <guid>https://qingting-zheng.github.io:443/tech/2018-07/%E6%AF%8F%E5%91%A8paper%E7%B2%BE%E8%AF%BB2-sentence-representation%E7%B3%BB%E5%88%97%E6%B3%9B%E8%AF%BB/</guid>
      <description>前言 原本计划是每周一篇论文精读，然而实际上由于项目上安排较紧，距离上一次论文精读已经过了几个月。现在项目算是告一段落，在项目中也算是找到一些问题所在，正在看感兴趣的论文（这期是赶不上了）。正好媛源的实习生肖风顺正在做关于句向量的调研，找了些相关论文，我也旁听了两次，顺便就把这两次旁听的结果记录一下，顺便也对其中内容也简要的过一遍大概思路，虽然这样算不上什么“论文精读”，但本来精读和泛读就要结合么😄</description>
    </item>
    
    <item>
      <title>服务发现：Spring Cloud Netflix Eureka （十七） Eureka Server服务剔除</title>
      <link>https://qingting-zheng.github.io:443/tech/2018-07/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0spring-cloud-netflix-eureka-%E5%8D%81%E4%B8%83-eureka-server%E6%9C%8D%E5%8A%A1%E5%89%94%E9%99%A4/</link>
      <pubDate>Mon, 23 Jul 2018 10:01:15 +0800</pubDate>
      
      <guid>https://qingting-zheng.github.io:443/tech/2018-07/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0spring-cloud-netflix-eureka-%E5%8D%81%E4%B8%83-eureka-server%E6%9C%8D%E5%8A%A1%E5%89%94%E9%99%A4/</guid>
      <description>系列文章《Spring Cloud Netflix Eureka》的介绍与深入讲解。欢迎关注、转发、评论。 服务剔除 如果服务在注册后，既没有续约，也没有下线(服务崩溃或者网络异常等原因)，那么服务的状态就处于未可知的状态，不能保证能够从该服务中获取到回馈，所以需要服务剔除evict()来定时清理这些不稳定的服务，该方法会将注册表中所有过期的租约全部剔除。 @Override public void evict() { evict(0l); } public void evict(long additionalLeaseMs) { // 自我保护相关，如果出现该状态，不允许剔除服务 if</description>
    </item>
    
    <item>
      <title>服务发现：Spring Cloud Netflix Eureka （十六） Eureka Server服务续约</title>
      <link>https://qingting-zheng.github.io:443/tech/2018-07/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0spring-cloud-netflix-eureka-%E5%8D%81%E5%85%AD-eureka-server%E6%9C%8D%E5%8A%A1%E7%BB%AD%E7%BA%A6/</link>
      <pubDate>Tue, 03 Jul 2018 10:01:15 +0800</pubDate>
      
      <guid>https://qingting-zheng.github.io:443/tech/2018-07/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0spring-cloud-netflix-eureka-%E5%8D%81%E5%85%AD-eureka-server%E6%9C%8D%E5%8A%A1%E7%BB%AD%E7%BA%A6/</guid>
      <description>系列文章《Spring Cloud Netflix Eureka》的介绍与深入讲解。欢迎关注、转发、评论。 服务续约 接着上一篇文章，我么来看下服务续约 renew()方法，即单纯的续租操作，不像register()方法携带了服务实例信息InstanceInfo，仅更新Server中的注册表的租约的时间。 public boolean renew(String appName, String id, boolean isReplication) { RENEW.increment(isReplication); // 根据appName获取到服务集群的租约集合 Map&amp;lt;String, Lease&amp;lt;InstanceInfo&amp;gt;&amp;gt; gMap = registry.get(appName); Lease&amp;lt;InstanceInfo&amp;gt; leaseToRenew = null; if (gMap != null) { leaseToRenew = gMap.get(id); } // 租约不存在，直接返回fa</description>
    </item>
    
    <item>
      <title>服务发现：Spring Cloud Netflix Eureka （十五） Eureka Server 服务注册</title>
      <link>https://qingting-zheng.github.io:443/tech/2018-06/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0spring-cloud-netflix-eureka-%E5%8D%81%E4%BA%94-eureka-server-%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C/</link>
      <pubDate>Wed, 20 Jun 2018 10:01:15 +0800</pubDate>
      
      <guid>https://qingting-zheng.github.io:443/tech/2018-06/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0spring-cloud-netflix-eureka-%E5%8D%81%E4%BA%94-eureka-server-%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C/</guid>
      <description>系列文章《Spring Cloud Netflix Eureka》的介绍与深入讲解。欢迎关注、转发、评论。 服务注册 // AbstractInstanceRegistry public void register(InstanceInfo registrant, int leaseDuration, boolean isReplication) { try { // 获取读锁 read.lock(); // 这里的registry是 // ConcurrentHashMap&amp;lt;String, Map&amp;lt;String, Lease&amp;lt;InstanceInfo&amp;gt;&amp;gt;&amp;gt; registry // 根据appName对服务实例集群进行分类 Map&amp;lt;String, Lease&amp;lt;InstanceInfo&amp;gt;&amp;gt; gMap = registry.get(registrant.getAppName()); REGISTER.increment(isReplication); if (gMap == null) { final ConcurrentHashMap&amp;lt;String, Lease&amp;lt;InstanceInfo&amp;gt;&amp;gt; gNewMap = new ConcurrentHashMap&amp;lt;String, Lease&amp;lt;InstanceInfo&amp;gt;&amp;gt;(); // 这里有一个比较严谨操作的，防止在添加新的服务实例集群租约时把已有其他的线程 // 添加的集群租约覆盖掉， // 这与putIfAbsent的机制相关 // 如果存在该键值，直</description>
    </item>
    
    <item>
      <title>服务发现：Spring Cloud Netflix Eureka （十四）服务端核心代码</title>
      <link>https://qingting-zheng.github.io:443/tech/2018-06/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0spring-cloud-netflix-eureka-%E5%8D%81%E5%9B%9B%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%A0%B8%E5%BF%83%E4%BB%A3%E7%A0%81/</link>
      <pubDate>Thu, 14 Jun 2018 10:01:15 +0800</pubDate>
      
      <guid>https://qingting-zheng.github.io:443/tech/2018-06/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0spring-cloud-netflix-eureka-%E5%8D%81%E5%9B%9B%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%A0%B8%E5%BF%83%E4%BB%A3%E7%A0%81/</guid>
      <description>系列文章《Spring Cloud Netflix Eureka》的介绍与深入讲解。欢迎关注、转发、评论。 服务端核心代码 在Eureka中，eureka-server模块是通过eureka-client、eureka-core、以及eureka-resource(eureka-server运行JSP界面)三个模块打包而成，由于euerka-client已经在上一节进行了较为完整的介绍，所以服务端核心代码主要位于eureka-</description>
    </item>
    
    <item>
      <title>服务发现：Spring Cloud Netflix Eureka （十三） Eureka Server 配置类介绍</title>
      <link>https://qingting-zheng.github.io:443/tech/2018-05/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0spring-cloud-netflix-eureka-%E5%8D%81%E4%B8%89-eureka-server-%E9%85%8D%E7%BD%AE%E7%B1%BB%E4%BB%8B%E7%BB%8D/</link>
      <pubDate>Thu, 24 May 2018 10:01:15 +0800</pubDate>
      
      <guid>https://qingting-zheng.github.io:443/tech/2018-05/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0spring-cloud-netflix-eureka-%E5%8D%81%E4%B8%89-eureka-server-%E9%85%8D%E7%BD%AE%E7%B1%BB%E4%BB%8B%E7%BB%8D/</guid>
      <description>系列文章《Spring Cloud Netflix Eureka》的介绍与深入讲解。欢迎关注、转发、评论。 Eureka Server 配置类介绍 从spring-cloud-starter-netflix-eureka-server的spring.factories中 org.springframework.boot.autoconfigure.EnableAutoConfiguration=\ org.springframework.cloud.netflix.eureka.server.EurekaServerAutoConfiguration 可以发现EurekaServerAutoConfiguration配置文件被激活。 打开SpringBoot的Debug模式： logging:level:org.springfram</description>
    </item>
    
    <item>
      <title>服务发现：Spring Cloud Netflix Eureka （十二）服务下线</title>
      <link>https://qingting-zheng.github.io:443/tech/2018-05/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0spring-cloud-netflix-eureka-%E5%8D%81%E4%BA%8C%E6%9C%8D%E5%8A%A1%E4%B8%8B%E7%BA%BF/</link>
      <pubDate>Sat, 12 May 2018 10:01:15 +0800</pubDate>
      
      <guid>https://qingting-zheng.github.io:443/tech/2018-05/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0spring-cloud-netflix-eureka-%E5%8D%81%E4%BA%8C%E6%9C%8D%E5%8A%A1%E4%B8%8B%E7%BA%BF/</guid>
      <description>系列文章《Spring Cloud Netflix Eureka》的介绍与深入讲解。欢迎关注、转发、评论。 服务下线 到此为止，已经通过DiscoveryClient的构造方法，遍历了DiscoveryClient上基本所有方法，也了解Eureka Client如何服务发现(fetchRegistry()拉取Eureka Server上的注册表信息，之后通过定时任务CacheRefreshThread定时拉取)，服务注册(第一次注</description>
    </item>
    
    <item>
      <title>服务发现：Spring Cloud Netflix Eureka （十一）服务注册与服务按需注册</title>
      <link>https://qingting-zheng.github.io:443/tech/2018-04/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0spring-cloud-netflix-eureka-%E5%8D%81%E4%B8%80%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E6%9C%8D%E5%8A%A1%E6%8C%89%E9%9C%80%E6%B3%A8%E5%86%8C/</link>
      <pubDate>Sat, 21 Apr 2018 10:01:15 +0800</pubDate>
      
      <guid>https://qingting-zheng.github.io:443/tech/2018-04/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0spring-cloud-netflix-eureka-%E5%8D%81%E4%B8%80%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E6%9C%8D%E5%8A%A1%E6%8C%89%E9%9C%80%E6%B3%A8%E5%86%8C/</guid>
      <description>系列文章《Spring Cloud Netflix Eureka》的介绍与深入讲解。欢迎关注、转发、评论。 服务注册与服务按需注册 介绍到这里，似乎发现Eureka Client的与Eureka Server的服务注册和发现基本上都是实现了，但是好像缺了点什么，如果Eureka Client的InstanceInfo中的信息发生改变时(例如status发生改变)，是不是应该更新在Server上的注册表中的服务实例的信息？ 重新回到in</description>
    </item>
    
    <item>
      <title>服务发现：Spring Cloud Netflix Eureka （十）注册表缓存刷新定时器与续租(心跳)定时器</title>
      <link>https://qingting-zheng.github.io:443/tech/2018-04/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0spring-cloud-netflix-eureka-%E5%8D%81%E6%B3%A8%E5%86%8C%E8%A1%A8%E7%BC%93%E5%AD%98%E5%88%B7%E6%96%B0%E5%AE%9A%E6%97%B6%E5%99%A8%E4%B8%8E%E7%BB%AD%E7%A7%9F%E5%BF%83%E8%B7%B3%E5%AE%9A%E6%97%B6%E5%99%A8/</link>
      <pubDate>Wed, 11 Apr 2018 10:01:15 +0800</pubDate>
      
      <guid>https://qingting-zheng.github.io:443/tech/2018-04/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0spring-cloud-netflix-eureka-%E5%8D%81%E6%B3%A8%E5%86%8C%E8%A1%A8%E7%BC%93%E5%AD%98%E5%88%B7%E6%96%B0%E5%AE%9A%E6%97%B6%E5%99%A8%E4%B8%8E%E7%BB%AD%E7%A7%9F%E5%BF%83%E8%B7%B3%E5%AE%9A%E6%97%B6%E5%99%A8/</guid>
      <description>系列文章《Spring Cloud Netflix Eureka》的介绍与深入讲解。欢迎关注、转发、评论。 注册表缓存刷新定时器与续租(心跳)定时器 很明显，服务注册应该是一个持续的过程，所以DiscoveryClient中通过一个定时任务完成，不间断地与Eureka Server进行通信，维持自己在注册表上的租约。 在initScheduledTasks()方法中初始化了两个定时器任务，一个用于刷新本地注册表的信息，一个用于注册</description>
    </item>
    
    <item>
      <title>慢学Docker(3) Docker Hub速度蜗牛爬怎么办?</title>
      <link>https://qingting-zheng.github.io:443/tech/2018-03/%E6%85%A2%E5%AD%A6docker3-docker-hub%E9%80%9F%E5%BA%A6%E8%9C%97%E7%89%9B%E7%88%AC%E6%80%8E%E4%B9%88%E5%8A%9E/</link>
      <pubDate>Tue, 20 Mar 2018 23:47:17 +0800</pubDate>
      
      <guid>https://qingting-zheng.github.io:443/tech/2018-03/%E6%85%A2%E5%AD%A6docker3-docker-hub%E9%80%9F%E5%BA%A6%E8%9C%97%E7%89%9B%E7%88%AC%E6%80%8E%E4%B9%88%E5%8A%9E/</guid>
      <description>前言 其实两三个月前使用docker hub不管push还是pull虽然算不上光速但也不错。但今天修铭哥问我关于docker的使用，直接用Dockerfile建镜像不知道为什么成功不了，于是想直接pull我已经上传到docker hub中的镜像，结果就这1.3G左右的东西，下了整整一天。其中某layer就52M也能下半天。 晚上回家想下vue的docker镜像，几个四五十M的layer也慢悠悠下着，终于确</description>
    </item>
    
    <item>
      <title>服务发现：Spring Cloud Netflix Eureka （九）Eureka 客户端增量式拉取注册表信息</title>
      <link>https://qingting-zheng.github.io:443/tech/2018-03/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0spring-cloud-netflix-eureka-%E4%B9%9Deureka-%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%A2%9E%E9%87%8F%E5%BC%8F%E6%8B%89%E5%8F%96%E6%B3%A8%E5%86%8C%E8%A1%A8%E4%BF%A1%E6%81%AF/</link>
      <pubDate>Sun, 11 Mar 2018 10:01:15 +0800</pubDate>
      
      <guid>https://qingting-zheng.github.io:443/tech/2018-03/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0spring-cloud-netflix-eureka-%E4%B9%9Deureka-%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%A2%9E%E9%87%8F%E5%BC%8F%E6%8B%89%E5%8F%96%E6%B3%A8%E5%86%8C%E8%A1%A8%E4%BF%A1%E6%81%AF/</guid>
      <description>系列文章《Spring Cloud Netflix Eureka》的介绍与深入讲解。欢迎关注、转发、评论。 增量式拉取注册表信息 接着查看一下增量式的拉取方式，一般发生在第一次拉取注册表信息之后，拉取的信息定义为从某一段时间之后发生的所有变更的信息，通常来讲是3分钟，在获取到更新的delta，会根据delta中的增量更新对本地的数据进行更新，与getAndStoreFullRegistry()一样，也通过fetchRegist</description>
    </item>
    
    <item>
      <title>服务发现：Spring Cloud Netflix Eureka （八）Eureka 客户端拉取信息</title>
      <link>https://qingting-zheng.github.io:443/tech/2018-03/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0spring-cloud-netflix-eureka-%E5%85%ABeureka-%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%8B%89%E5%8F%96%E4%BF%A1%E6%81%AF/</link>
      <pubDate>Wed, 07 Mar 2018 10:01:15 +0800</pubDate>
      
      <guid>https://qingting-zheng.github.io:443/tech/2018-03/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0spring-cloud-netflix-eureka-%E5%85%ABeureka-%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%8B%89%E5%8F%96%E4%BF%A1%E6%81%AF/</guid>
      <description>系列文章《Spring Cloud Netflix Eureka》的介绍与深入讲解。欢迎关注、转发、评论。 从Eureka Server中拉取注册表信息 通过如下的逻辑判断： if (clientConfig.shouldFetchRegistry() &amp;amp;&amp;amp; !fetchRegistry(false)) { fetchRegistryFromBackup(); } 如果EurekaClientConfig.shouldFetchRegistry()为true时，那么fetchRegistry()方法将会被调用，，在Eureka Client向Eureka Server注册前，需要先从Eureka Server拉</description>
    </item>
    
    <item>
      <title>服务发现：Spring Cloud Netflix Eureka （七）Eureka 客户端的服务注册与发现</title>
      <link>https://qingting-zheng.github.io:443/tech/2018-02/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0spring-cloud-netflix-eureka-%E4%B8%83eureka-%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0/</link>
      <pubDate>Tue, 27 Feb 2018 10:01:15 +0800</pubDate>
      
      <guid>https://qingting-zheng.github.io:443/tech/2018-02/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0spring-cloud-netflix-eureka-%E4%B8%83eureka-%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0/</guid>
      <description>系列文章《Spring Cloud Netflix Eureka》的介绍与深入讲解。欢迎关注、转发、评论。 客户端的服务注册与发现 在DiscoveryClient的代码中，有实现服务注册与发现的功能的具体代码。在DiscoveryClient构造函数中，Eureka Client会执行从Eureka Server中拉取注册表信息，注册自身等操作。 DiscoveryClient的构造函数如下： DiscoveryClient(ApplicationInfoManager applicationInfoManager, EurekaClientConfig config, AbstractDiscoveryClientOptionalArgs args, Provider&amp;lt;BackupRegistry&amp;gt; backupRegistryProvider) Application</description>
    </item>
    
    <item>
      <title>服务发现：Spring Cloud Netflix Eureka （六） Eureka Client 客户端核心代码</title>
      <link>https://qingting-zheng.github.io:443/tech/2018-02/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0spring-cloud-netflix-eureka-%E5%85%AD-eureka-client-%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%A0%B8%E5%BF%83%E4%BB%A3%E7%A0%81/</link>
      <pubDate>Mon, 26 Feb 2018 10:01:15 +0800</pubDate>
      
      <guid>https://qingting-zheng.github.io:443/tech/2018-02/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0spring-cloud-netflix-eureka-%E5%85%AD-eureka-client-%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%A0%B8%E5%BF%83%E4%BB%A3%E7%A0%81/</guid>
      <description>系列文章《Spring Cloud Netflix Eureka》的介绍与深入讲解。欢迎关注、转发、评论。 包结构 主要的代码位于eureka-client中，项目的module为eureka-client，版本为v1.8.7，这是Finchley版本的Spring Cloud所依赖的eureka版本 包结构如下 简要的包介绍: com.netflix.appinfo: 主要是关于eureka-client的配置信息类，如上面提及的EurekaInstanceConfig，</description>
    </item>
    
    <item>
      <title>服务发现：Spring Cloud Netflix Eureka （五） Eureka Client 源码分析</title>
      <link>https://qingting-zheng.github.io:443/tech/2018-02/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0spring-cloud-netflix-eureka-%E4%BA%94-eureka-client-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</link>
      <pubDate>Tue, 20 Feb 2018 10:01:15 +0800</pubDate>
      
      <guid>https://qingting-zheng.github.io:443/tech/2018-02/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0spring-cloud-netflix-eureka-%E4%BA%94-eureka-client-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</guid>
      <description>系列文章《Spring Cloud Netflix Eureka》的介绍与深入讲解。欢迎关注、转发、评论。 在Finchley版本的SpringCloud中，不需要添加任何的额外的注解就可以登记为Eureka Client，只需要在pom文件中添加spring-cloud-starter-netflix-eureka-client的依赖。 为了跟踪Eureka的运行机制，读者可以打开SpringBoot的Debug模式来查看更多</description>
    </item>
    
    <item>
      <title>服务发现：Spring Cloud Netflix Eureka （四） Eureka 核心架构图</title>
      <link>https://qingting-zheng.github.io:443/tech/2018-02/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0spring-cloud-netflix-eureka-%E5%9B%9B-eureka-%E6%A0%B8%E5%BF%83%E6%9E%B6%E6%9E%84%E5%9B%BE/</link>
      <pubDate>Fri, 16 Feb 2018 10:01:15 +0800</pubDate>
      
      <guid>https://qingting-zheng.github.io:443/tech/2018-02/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0spring-cloud-netflix-eureka-%E5%9B%9B-eureka-%E6%A0%B8%E5%BF%83%E6%9E%B6%E6%9E%84%E5%9B%BE/</guid>
      <description>系列文章《Spring Cloud Netflix Eureka》的介绍与深入讲解。欢迎关注、转发、评论。 核心架构图 目前SpringCloud的Finchley版本中采用的Eureka的版本的为1.8，本部分的架构图主要基于Eureka 1.0的进行介绍。 这幅图来自于Eureka的官方提供的架构图，GitHub地址为https://github.com/Netflix/eureka，下面将对这里的概念以及工作过程进行介绍，以</description>
    </item>
    
    <item>
      <title>服务发现：Spring Cloud Netflix Eureka （三）微服务接入 Eureka </title>
      <link>https://qingting-zheng.github.io:443/tech/2018-02/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0spring-cloud-netflix-eureka-%E4%B8%89%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%8E%A5%E5%85%A5-eureka/</link>
      <pubDate>Mon, 12 Feb 2018 10:01:15 +0800</pubDate>
      
      <guid>https://qingting-zheng.github.io:443/tech/2018-02/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0spring-cloud-netflix-eureka-%E4%B8%89%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%8E%A5%E5%85%A5-eureka/</guid>
      <description>系列文章《Spring Cloud Netflix Eureka》的介绍与深入讲解。欢迎关注、转发、评论。 与服务注册中心交换信息 当一个服务实例拥有DiscovryClient就可以从Eureka Server中发现其他的服务实例，以下例子在Eureka Client注入一个DiscoveryClient，并从Eureka Server获取服务实例的信息。 在chapter2-eureka-client添加一个ServiceInst</description>
    </item>
    
    <item>
      <title>服务发现：Spring Cloud Netflix Eureka （二）使用 Eureka 作为服务发现组件</title>
      <link>https://qingting-zheng.github.io:443/tech/2018-02/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0spring-cloud-netflix-eureka-%E4%BA%8C%E4%BD%BF%E7%94%A8-eureka-%E4%BD%9C%E4%B8%BA%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E7%BB%84%E4%BB%B6/</link>
      <pubDate>Thu, 08 Feb 2018 10:01:15 +0800</pubDate>
      
      <guid>https://qingting-zheng.github.io:443/tech/2018-02/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0spring-cloud-netflix-eureka-%E4%BA%8C%E4%BD%BF%E7%94%A8-eureka-%E4%BD%9C%E4%B8%BA%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E7%BB%84%E4%BB%B6/</guid>
      <description>系列文章《Spring Cloud Netflix Eureka》的介绍与深入讲解。欢迎关注、转发、评论。 搭建Eureka服务注册中心 可以通过Idea快速搭建包含Eurake Server依赖的SpringBoot项目 主要依赖 &amp;lt;dependency&amp;gt;// eureka-client相关依赖&amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;&amp;lt;artifactId&amp;gt;spring-cl</description>
    </item>
    
    <item>
      <title>Docker for datascience: 从纠结到放弃</title>
      <link>https://qingting-zheng.github.io:443/tech/2018-02/docker-for-datascience-%E4%BB%8E%E7%BA%A0%E7%BB%93%E5%88%B0%E6%94%BE%E5%BC%83/</link>
      <pubDate>Tue, 06 Feb 2018 10:01:15 +0800</pubDate>
      
      <guid>https://qingting-zheng.github.io:443/tech/2018-02/docker-for-datascience-%E4%BB%8E%E7%BA%A0%E7%BB%93%E5%88%B0%E6%94%BE%E5%BC%83/</guid>
      <description>表示我是不纠结不死星人。 先是由jupyter stacks突发奇想，于是纠结于想建立属于自己的docker族系，特别是用来做数据科学&amp;amp;机器学习。想要不用Anaconda、甚至不用conda，自己按照使用习惯安装我自己需要的包、想使用最小的alpine作为基镜像，因此开始走上不归路。 想要使用bash而不是ash，想要默认调用bash，想要调用bash时能默认出现现在使用用户及现在所在文件夹。折</description>
    </item>
    
    <item>
      <title>服务发现：Spring Cloud Netflix Eureka （一）介绍</title>
      <link>https://qingting-zheng.github.io:443/tech/2018-01/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0spring-cloud-netflix-eureka-%E4%B8%80%E4%BB%8B%E7%BB%8D/</link>
      <pubDate>Fri, 26 Jan 2018 12:32:58 +0800</pubDate>
      
      <guid>https://qingting-zheng.github.io:443/tech/2018-01/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0spring-cloud-netflix-eureka-%E4%B8%80%E4%BB%8B%E7%BB%8D/</guid>
      <description>系列文章《Spring Cloud Netflix Eureka》的介绍与深入讲解。欢迎关注、转发、评论。 在传统的单体应用中，组件之间的调用通过有规范约束的接口进行，实现不同模块间良好协作。在微服务架构中，原本的“巨石”应用按照业务被分割成相对独立的、提供特定功能的微服务，每一个微服务都可以通过集群或者其他方式进行动态的扩展，每一个微服务实例的网络地址都可能动态变化，这使得原本通过硬编码地址的调用方式失去了作用。微服务架构</description>
    </item>
    
  </channel>
</rss>
